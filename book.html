
    <link href='http://fonts.googleapis.com/css?family=Titillium+Web' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
    <style>
      html {
  font-family: 'Roboto';
  font-size: 24px;
}

#dedication {
  page-break-before: always;
  padding-top: 250px;
  width: 50%;
  margin: auto;
  font-style: italic;
  line-height: 1.5em;
}

h1 {
  padding-top: 100px;
  page-break-before: always;
}

h2 {
  padding-top: 75px;
}

h2#write-your-own-co, h2#real-implementation-of-co, h2#write-your-own-transpiler {
  page-break-before: always;
}

.page-break {
  page-break-before: always;
}

h1,h2,h3,h4,p,ul,ol,:not(li) > pre {
  margin-left: 50px;
  margin-right: 50px;
}

pre {
  border: 1px solid #dfdfdf;
  padding: 15px;
}

code {
  font-family: 'Droid Sans Mono';
}

p, li {
  line-height: 1.5em;
}

p code {
  color: #232323;
}

h1 a, h2 a, h3 a, li a {
  color: black;
  float: right;
  text-decoration: none;
  font-weight: bold;
}

.page-num {
  position: absolute;
  right: 50px;
  font-size: 0.75em;
  font-color: #333333;
}

.cover img {
  position: relative;
  left: -250px;
  top: -8px;
  height: 1300px;
  margin: 0px;
  padding: 0px;
}

.cover .info {
  position: absolute;
  top: 1240px;
  left: -8px;
  background-color: black;
  color: white;
  height: 441px;
  width: 1500px;
}

.title {
  padding-left: 50px;
  font-family: 'Titillium Web';
  font-size: 48pt;
  font-weight: bold;
}

.author {
  padding-left: 50px;
  font-family: 'Titillium Web';
  font-size: 36pt;
  margin-top: 15px;
}

.top-triangle {
  position: absolute;
  top: 1100px;
  left: 0px;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 200px 0 0 2000px;
  border-color: transparent transparent transparent black;
}

/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-javadoc {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.css .rule .hljs-keyword,
.hljs-winutils,
.nginx .hljs-title,
.hljs-subst,
.hljs-request,
.hljs-status {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-hexcolor,
.ruby .hljs-constant {
  color: #008080;
}

.hljs-string,
.hljs-tag .hljs-value,
.hljs-phpdoc,
.hljs-dartdoc,
.tex .hljs-formula {
  color: #d14;
}

.hljs-title,
.hljs-id,
.scss .hljs-preprocessor {
  color: #900;
  font-weight: bold;
}

.hljs-list .hljs-keyword,
.hljs-subst {
  font-weight: normal;
}

.hljs-class .hljs-title,
.hljs-type,
.vhdl .hljs-literal,
.tex .hljs-command {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-tag .hljs-title,
.hljs-rules .hljs-property,
.django .hljs-tag .hljs-keyword {
  color: #000080;
  font-weight: normal;
}

.hljs-attribute,
.hljs-variable,
.lisp .hljs-body {
  color: #008080;
}

.hljs-regexp {
  color: #009926;
}

.hljs-symbol,
.ruby .hljs-symbol .hljs-string,
.lisp .hljs-keyword,
.clojure .hljs-keyword,
.scheme .hljs-keyword,
.tex .hljs-special,
.hljs-prompt {
  color: #990073;
}

.hljs-built_in {
  color: #0086b3;
}

.hljs-preprocessor,
.hljs-pragma,
.hljs-pi,
.hljs-doctype,
.hljs-shebang,
.hljs-cdata {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.diff .hljs-change {
  background: #0086b3;
}

.hljs-chunk {
  color: #aaa;
}

    </style>
    <div id="content">
      <div class="cover">
  <img src="http://i.imgur.com/nG4gisP.jpg" />
  <div class="top-triangle"></div>
  <div class="info">
    <div class="title">
      The 80/20 Guide to ES2015 Generators
    </div>
    <div class="author">
      Valeri Karpov
    </div>
  </div>
</div>

      <div id="dedication">
  This book is dedicated to my mother Olga, who taught me to always aim high.
</div>

      <h1 id="table-of-contents">Table of Contents</h1>
<h3 id="0-how-to-use-this-book-1-1-">0. How To Use This Book <a href="#1">1</a></h3>
<h3 id="1-getting-started-with-generators-3-3-">1. Getting Started With Generators <a href="#3">3</a></h3>
<ol>
<li>What is a Generator? <a href="#3">3</a></li>
<li>Case Study: Async Fibonacci <a href="#5">5</a></li>
<li>For/Of Loops <a href="#7">7</a></li>
<li>Error Handling <a href="#9">9</a></li>
<li>Case Study: Handling Async Errors <a href="#10">10</a></li>
</ol>
<h3 id="2-asynchronous-coroutines-12-12-">2. Asynchronous Coroutines <a href="#12">12</a></h3>
<ol>
<li>Promises and Thunks <a href="#12">12</a></li>
<li>Write Your Own Co <a href="#18">18</a></li>
<li>Limitations <a href="#20">20</a></li>
<li>Real Implementation of Co <a href="#22">22</a></li>
</ol>
<h3 id="3-koa-and-middleware-27-27-">3. Koa and Middleware <a href="#27">27</a></h3>
<ol>
<li>The koa-compose Module <a href="#28">28</a></li>
<li>The Koa Web Framework <a href="#30">30</a></li>
<li>Limitations of koa-compose and Koa <a href="#33">33</a></li>
</ol>
<h3 id="4-transpiling-35-35-">4. Transpiling <a href="#35">35</a></h3>
<ol>
<li>Introducing Regenerator <a href="#35">35</a></li>
<li>Faking a Generator Function <a href="#37">37</a></li>
<li>Parsing Generators With Esprima <a href="#42">42</a></li>
<li>Write Your Own Transpiler <a href="#45">45</a></li>
</ol>
<h3 id="5-moving-on-50-50-">5. Moving On <a href="#50">50</a></h3>

      <h1 id="how-to-use-this-book">How To Use This Book</h1>
<p>This is not just another tech book that sits up on your bookshelf gathering
dust. I think of this ebook as something halfway between a blog post and
a full book: focused and concise like a blog post, in-depth and rigorous like
a pure math textbook. The purpose of this ebook is to take you from a generators
novice to someone who would be comfortable discussing co internals in 1 to 2
hours. This ebook is meant to be read in 1-2 sessions (its only 50 pages!),
although you may also choose to read one chapter at a time.</p>
<p>What is this ebook focused on?</p>
<ul>
<li>80/20 principle. There&#39;s a lot of tooling related to generators out there:
transpilers, modules, build systems, etc. This book is focused solely on
generators and other features defined in the ES2015 specification. The <strong>only</strong>
dependency is Node.js &gt;= 4.0.0 and npm.
In particular, this ebook will <strong>not</strong> use webpack, react, babel, gulp, grunt,
TypeScript, CoffeeScript, AngularJS, Dart, or any other framework,
preprocessor, or hype train.</li>
<li>The co module and asynchronous coroutines. To better understand how generators
work in an asynchronous language like JavaScript, you&#39;ll write your own
minimal version of co from scratch. Your co implementation will enable you
to write asynchronous code without callbacks. For instance,</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Make an HTTP request to google's home page</span>
  <span class="hljs-keyword">const</span> google = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://google.com'</span>)).text;
  <span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/google/i</span>;
  <span class="hljs-comment">// The number of times "Google" appears on google.com</span>
  regexp.match(google).length;
});
</code></pre>
<ul>
<li>Composing asynchronous coroutines. You&#39;ll learn about the generator-based
server-side web framework koa, and write your own minimal koa implementation.</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = koa();
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">yield</span> next;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>.now() - start); <span class="hljs-comment">// Will print approximately 1000</span>
});
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  setTimeout(() =&gt; { <span class="hljs-keyword">yield</span> next; }, <span class="hljs-number">1000</span>);
});
app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p><br><br><br></p>
<ul>
<li>Transpiling generator functions into plain-old functions for ES5 environments.
You&#39;ll learn about the open-source transpiler regenerator, and write a
rudimentary transpiler using the open-source JavaScript parser esprima.</li>
</ul>
<p>This book strives to minimize external dependencies. However, in the
interest of providing realistic examples and minimizing tangential work, this
book utilizes a handful of npm modules.</p>
<ul>
<li>co 4.6.0</li>
<li>escodegen 1.8.0</li>
<li>esprima 2.7.1</li>
<li>estraverse 4.1.1</li>
<li>koa 1.1.2</li>
<li>koa-compose 2.3.0</li>
<li>regenerator 0.8.42</li>
<li>superagent 1.6.1</li>
<li>thunkify 2.1.2</li>
</ul>
<p>All this book&#39;s code examples are generated from a mocha test suite using
the acquit npm module. The tests are run using Node.js 5.4.1. However, if you
find any issues, please report them
on <br>
<a href="https://github.com/vkarpov15/generators-book-issues">github.com/vkarpov15/generators-book-issues</a>.</p>
<p>For the most part, the code samples in this book can be run as-is in Node.js
with a little massaging. However, for cases when you may struggle with running
the code samples, the raw mocha test cases that generate the
code examples for chapters 1-4 are packaged with this book as
<code>chapterX.test.js</code>.</p>
<p>Are you ready to become a master of ES2015 generators? Let&#39;s get started!</p>

      <h1 id="chapter-1-getting-started">Chapter 1: Getting Started</h1>
<p>Generators are a powerful new feature in ES2015. Generators are far from a
new programming construct - they first appeared in 1975 and Python has had
them since Python 2.2 in 2001. However, as you&#39;ll see, generators are
even more powerful in an event-driven language like JavaScript. In JavaScript
(assuming Node.js &gt;= 4.0.0), a <strong>generator function</strong> is defined as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
};
</code></pre>
<p>However, if you run <code>generatorFunction</code>, you&#39;ll notice that the return value
is an object.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>); };
<span class="hljs-literal">undefined</span>
&gt; generatorFunction()
{}
</code></pre><p>That&#39;s because a generator function creates and returns a <strong>generator object</strong>.
Typically, the term <strong>generator</strong> refers to a generator object rather than
a generator function. A generator object has a single function, <code>next()</code>.
If you execute the generator object&#39;s <code>next()</code> function, you&#39;ll notice
that Node.js printed &#39;Hello, World!&#39; to the screen.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>); };
<span class="hljs-literal">undefined</span>
&gt; generatorFunction()
{}
&gt; generatorFunction().next()
Hello, World!
{ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> }
&gt;
</code></pre><p>Notice that <code>next()</code> returned an object, <code>{ value: undefined, done: true }</code>.
The meaning of this object is tied to the <code>yield</code> keyword. To introduce you
to the <code>yield</code> keyword, consider the following generator function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>;
};
</code></pre>
<p><br><br><br><br><br>
<br></p>
<p>Let&#39;s see what happens when you call <code>next()</code> on the resulting generator.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>; };
<span class="hljs-literal">undefined</span>
&gt; <span class="hljs-keyword">var</span> generator = generatorFunction();
<span class="hljs-literal">undefined</span>
&gt; generator.next();
{ value: <span class="hljs-string">'Hello, World!'</span>, done: <span class="hljs-literal">false</span> }
&gt; generator.next();
{ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> }
&gt;
</code></pre><p>Notice that, the first time you call <code>generator.next()</code>, the <code>value</code> property
is equal to the string your generator function yielded. You can think of
<code>yield</code> as the generator-specific equivalent of the <code>return</code> statement.</p>
<p>You might be wondering why the return value of <code>generator.next()</code> has a <code>done</code>
property. The reason is tied to why <code>yield</code> is different from <code>return</code>.</p>
<h3 id="-yield-vs-return-"><code>yield</code> vs <code>return</code></h3>
<p>The <code>yield</code> keyword can be thought of as a <code>return</code> that allows <strong>re-entry</strong>.
In other words, once <code>return</code> executes, the currently executing function is
done forever. However, when you call <code>generator.next()</code>, the JavaScript
interpreter executes the generator function until the first <code>yield</code> statement.
When you call <code>generator.next()</code> again, the generator function picks up where
it left off. You can think of a generator as a function that can &quot;return&quot;
multiple values.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">'Hello'</span>;
  <span class="hljs-keyword">yield</span> message;
  message += <span class="hljs-string">', World!'</span>;
  <span class="hljs-keyword">yield</span> message;
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-comment">// { value: 'Hello', done: false };</span>
<span class="hljs-keyword">const</span> v1 = generator.next();
<span class="hljs-comment">// { value: 'Hello, World!', done: false }</span>
<span class="hljs-keyword">const</span> v2 = generator.next();
<span class="hljs-comment">// { value: undefined, done: true }</span>
<span class="hljs-keyword">const</span> v3 = generator.next();
</code></pre>
<h3 id="re-entry">Re-entry</h3>
<p>The most important detail from the above example is that, when <code>yield</code>
executes, the generator function stops executing until the next time you call
<code>generator.next()</code>. You can call <code>generator.next()</code> whenever you want, even in
a <code>setTimeout()</code>. The JavaScript interpreter will re-enter the generator
function with the same state that it left off with.</p>
<p><br>
<br></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>) {
    <span class="hljs-keyword">yield</span> i;
    ++i;
  }
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-keyword">let</span> x = generator.next(); <span class="hljs-comment">// { value: 0, done: false }</span>
setTimeout(() =&gt; {
  x = generator.next(); <span class="hljs-comment">// { value: 1, done: false }</span>
  x = generator.next(); <span class="hljs-comment">// { value: 2, done: false }</span>
  x = generator.next(); <span class="hljs-comment">// { value: undefined, done: true }</span>
}, <span class="hljs-number">50</span>);
</code></pre>
<h3 id="-yield-vs-return-revisited"><code>yield</code> vs <code>return</code> revisited</h3>
<p>You may be wondering what happens when you use <code>return</code>
instead of <code>yield</code> in a generator. As you might expect,
<code>return</code> behaves similarly to <code>yield</code>, except for
<code>done</code> is set to true.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, World!'</span>;
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-comment">// { value: 'Hello, World!', done: true }</span>
<span class="hljs-keyword">const</span> v = generator.next();
</code></pre>
<h2 id="case-study-async-fibonacci">Case Study: Async Fibonacci</h2>
<p>The fact that you can execute <code>generator.next()</code> asynchronously hints at
why generators are so useful. You can execute <code>generator.next()</code> synchronously
or asynchronously without changing the implementation of the generator
function.</p>
<p><div class="page-break"></div>
<br><br></p>
<p>For instance, lets say you wrote a generator
function that computes the Fibonacci Sequence. Note that generator functions
can take parameters like any function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacciGenerator = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">let</span> back2 = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> back1 = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) {
    cur = back2 + back1;
    back2 = back1;
    back1 = cur;
    <span class="hljs-keyword">yield</span> cur;
  }

  <span class="hljs-keyword">return</span> cur;
};
</code></pre>
<p>You could compute the n-th Fibonacci number synchronously using the code
below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-keyword">let</span> it;
<span class="hljs-keyword">for</span> (it = fibonacci.next(); !it.done; it = fibonacci.next()) {}
it.value; <span class="hljs-comment">// 55, the 10th fibonacci number</span>
</code></pre>
<p>However, computing the n-th Fibonacci number synchronously is not a hard
problem without generators. To make things interesting, let&#39;s say you wanted
to compute a very large Fibonacci number <strong>without blocking the event loop</strong>.
Normally, a JavaScript for loop would block the event loop. In other words,
no other JavaScript code can execute until the for loop in the previous
example is done. This can get problematic if you want to compute the 100
millionth Fibonacci number in an Express route handler. Without generators,
breaking up a long-running calculation can be cumbersome.</p>
<p>However, since you have a generator function that yields after each iteration
of the for loop, you can call <code>generator.next()</code> in a <code>setInterval()</code>
function. This will compute the next Fibonacci number with each iteration of
the event loop, and so won&#39;t prevent Node.js from responding from incoming
requests. You can make your Fibonacci calculation asynchronous without
changing the generator function!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-comment">// And compute one new Fibonacci number with each iteration</span>
<span class="hljs-comment">// through the event loop.</span>
<span class="hljs-keyword">const</span> interval = setInterval(() =&gt; {
  <span class="hljs-keyword">const</span> res = fibonacci.next();
  <span class="hljs-keyword">if</span> (res.done) {
    clearInterval(interval);
    res.value; <span class="hljs-comment">// 55, the 10th fibonacci number</span>
  }
}, <span class="hljs-number">0</span>);
</code></pre>
<h2 id="for-of-loops">For/Of Loops</h2>
<p>Remember the for loop you saw for exhausting the Fibonacci generator?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (it = fibonacci.next(); !it.done; it = fibonacci.next()) {}
</code></pre>
<p>This for loop is a perfectly reasonable way of going through every value of
the generator. However, ES2015 introduces a much cleaner mechanism for
looping through generators: the <code>for-of</code> loop.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  x; <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
</code></pre>
<h3 id="iterators-and-iterables">Iterators and Iterables</h3>
<p>For/Of loops aren&#39;t just for generators. A generator is actually an instance
of a more general ES2015 concept called an iterator. An <strong>iterator</strong> is
any JavaScript object that has a <code>next()</code> function that returns
<code>{ value: Any, done: Boolean }</code>. A generator is one example of an iterator.
You can also iterate over arrays:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) {
  x; <span class="hljs-comment">// 1, 2, 3</span>
}
</code></pre>
<p>However, For/Of loops don&#39;t operate on iterators, they operate on iterables.
An <strong>iterable</strong> is an object that has a <code>Symbol.iterator</code> property which is
a function that returns an iterator. In other words, when you execute a
For/Of loop, the JavaScript interpreter looks for a <code>Symbol.iterator</code> property
on the object you&#39;re looping <code>of</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> iterable = {};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {} <span class="hljs-comment">// Throws an error</span>

<span class="hljs-comment">// But once you add a Symbol.iterator property, everything works!</span>
iterable[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fibonacciGenerator(<span class="hljs-number">10</span>);
};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {
  x; <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
</code></pre>
<h3 id="a-brief-overview-of-symbols">A Brief Overview of Symbols</h3>
<p><strong>Symbols</strong> are another new feature in ES2015. Since this book is about
generators, we won&#39;t explore symbols in depth, just enough to understand
what the mysterious <code>iterable[Symbol.iterator]</code> code in the previous example
is about.</p>
<p><br><br><br></p>
<p>You can think of a symbol as a unique identifier for a key on an object.
For instance, suppose you wrote your own programming language and defined
an iterable as an object that had a property named <code>iterator</code>. Now, every
object that has a property named <code>iterator</code> would be an iterable, which
could lead to some unpredictable behavior. For instance, suppose you added
a property named <code>iterator</code> to an array - now you&#39;ve accidentally broken
for/of loops for that array!</p>
<p>Symbols protect you from the issue of accidental string collision. No string
key is equal to <code>Symbol.iterator</code>, so you don&#39;t have to worry about
accidentally breaking an iterable. Furthermore, symbols don&#39;t appear in
the output of <code>Object.keys()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">Symbol</span>.iterator; <span class="hljs-comment">// Symbol(Symbol.iterator)</span>

<span class="hljs-keyword">let</span> iterable = {};
iterable[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fibonacciGenerator(<span class="hljs-number">10</span>);
};

iterable.iterator; <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Object</span>.keys(iterable); <span class="hljs-comment">// Empty array!</span>
</code></pre>
<h3 id="iterables-and-generators">Iterables and Generators</h3>
<p>The most important detail to note about generators and iterables is that
<em>generator objects</em> are iterables, not <em>generator functions</em>. In order words,
you can&#39;t run a for/of loop on a generator function.</p>
<pre><code class="lang-javascript">fibonacciGenerator[<span class="hljs-built_in">Symbol</span>.iterable]; <span class="hljs-comment">// Undefined</span>
fibonacciGenerator(<span class="hljs-number">10</span>)[<span class="hljs-built_in">Symbol</span>.iterable]; <span class="hljs-comment">// Function</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacciGenerator) {} <span class="hljs-comment">// Error!</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacciGenerator(<span class="hljs-number">10</span>)) {} <span class="hljs-comment">// Ok</span>
</code></pre>
<p>You may find it strange that the generator&#39;s
<code>Symbol.iterator</code> function returns itself given that generator functions are
not iterable. One reason for this decision is that a generator function can
take parameters. For instance, looping over <code>fibonacciGenerator(10)</code> would not
give the same results as looping over <code>fibonacciGenerator(11)</code>.</p>
<p>The second most important detail to note about generators and iterables
is that <code>generator[Symbol.iterator]</code> is a function that returns the
generator itself. This means that you can&#39;t loop over the same generator
twice. Once a generator is done, subsequent for/of loops will exit immediately.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
fibonacci[<span class="hljs-built_in">Symbol</span>.iterator]() === fibonacci; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  <span class="hljs-comment">// Doesn't run!</span>
}
</code></pre>
<h2 id="error-handling">Error Handling</h2>
<p>One detail that has been glossed over so far is how generators handle
exceptions. What happens when you divide by zero in a generator? As you
might have guessed, the <code>generator.next()</code> call throws an error.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops!'</span>);
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-comment">// throws an error</span>
generator.next();
</code></pre>
<p>The error&#39;s stack trace reflects the fact that <code>next()</code> was the function
that called the function that threw the error. In particular, if you call
<code>next()</code> asynchronously, you will lose the original stack trace.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops!'</span>);
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

setTimeout(() =&gt; {
  <span class="hljs-keyword">try</span> {
    generator.next();
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">/**
     * Error: oops!
     * at generatorFunction (book.js:2:15)
     * at next (native)
     * at null._onTimeout (book.js:18:21)
     * at Timer.listOnTimeout (timers.js:89:15)
     */</span>
    err.stack;
  }
}, <span class="hljs-number">0</span>);
</code></pre>
<h3 id="re-entry-with-error">Re-entry With Error</h3>
<p>When you think of generators, you need to think of 2 functions: the generator
function itself, and the function that&#39;s calling <code>next()</code> on the generator.
When the generator function calls <code>yield</code> or <code>return</code>, the calling function
regains control. When the calling function calls <code>next()</code>, the generator
function regains starts running again. There&#39;s another way the calling function
can give control back to the generator function: the <code>throw()</code> function.</p>
<p><br><br><br><br></p>
<p>The <code>throw()</code> function is a way for the calling function to tell the generator
function that something went wrong. In the generator function, this will look
like the <code>yield</code> statement threw an error. You can then use try/catch to
handle the error in the generator function. As you&#39;ll see in the next section,
this pattern is indispensable for working with asynchronous code and generators.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fakeFibonacciGenerator = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    error; <span class="hljs-comment">// Error: Expected 1, got 3</span>
  }
};
<span class="hljs-keyword">const</span> fibonacci = fakeFibonacciGenerator();

<span class="hljs-keyword">const</span> x = fibonacci.next();
fibonacci.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Expected 1, got <span class="hljs-subst">${x.value}</span>`</span>));
<span class="hljs-comment">// { value: undefined, done: true }</span>
fibonacci.next();
</code></pre>
<h2 id="case-study-handling-async-errors">Case Study: Handling Async Errors</h2>
<p>Remember that there are two functions involved in generator functions: the
generator function itself, and the function that calls <code>next()</code> on the
generator object. So far in this book, the function that calls <code>next()</code>
hasn&#39;t done any real work. The most complex example is the async Fibonacci
example, which acted as a scheduler for the Fibonacci generator.</p>
<p>One pivotal feature of generators is that the <code>next()</code> function can take
a parameter. That parameter then becomes the return value of the <code>yield</code>
statement in the generator function itself!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> fullName = <span class="hljs-keyword">yield</span> [<span class="hljs-string">'John'</span>, <span class="hljs-string">'Smith'</span>];
  fullName; <span class="hljs-comment">// 'John Smith'</span>
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-comment">// Execute up to the first `yield`</span>
<span class="hljs-keyword">const</span> next = generator.next();
<span class="hljs-comment">// Join ['John', 'Smith'] =&gt; 'John Smith' and use it as the</span>
<span class="hljs-comment">// result of `yield`, then execute the rest of the generator function</span>
generator.next(next.value.join(<span class="hljs-string">' '</span>));
</code></pre>
<p>Once you combine this feature with the <code>throw()</code> function, you have everything
you need to have the generator function <code>yield</code> whenever it needs to do
an asynchronous operation. The calling function can then execute the
asynchronous operation, <code>throw()</code> any errors that occurred, and return the
result of the async operation using <code>next()</code>.</p>
<p><br><br><br></p>
<p>This means that your generator function doesn&#39;t need to worry about callbacks.
The calling function can be responsible for running asynchronous operations
and reporting any errors back to the generator function. For instance,
the below example shows how to run a generator function that yields an
asynchronous function without any errors.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'Hello, Async!'</span>), <span class="hljs-number">10</span>);
};

<span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> v = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">async</span>;
  v; <span class="hljs-comment">// 'Hello, Async!'</span>
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-keyword">const</span> res = generator.next();
res.value(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  generator.next(res);
});
</code></pre>
<p>Now suppose that the <code>async</code> function returns an error. The calling function
can then call <code>throw()</code> on the generator, and now your generator function
can handle this asynchronous operation with try/catch! As you&#39;ll see in the
coroutines chapter, this idea is the basis of the co library.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>)), <span class="hljs-number">10</span>);
};

<span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">async</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    error; <span class="hljs-comment">// Error: Oops!</span>
  }
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-keyword">const</span> res = generator.next();
res.value(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  generator.throw(error);
});
</code></pre>
<h1 id="chapter-2-asynchronous-coroutines">Chapter 2: Asynchronous Coroutines</h1>
<p>In chapter 1, you saw how to <code>yield</code> an asynchronous function from a generator.
The calling function would then execute the asynchronous function and resume
the generator function when the asynchronous function was done. This pattern
is an instance of an old (1958) programming concept known as a coroutine.
A <strong>coroutine</strong> is a function that can suspend its execution and defer to
another function. As you might have guessed, generator functions are coroutines,
and the <code>yield</code> statement is how a generator function defers control to another
function. You can think of a coroutine as two functions running side-by-side,
deferring control to each other at predefined points.</p>
<p>So why are coroutines special? In JavaScript, you typically need to specify a
callback for asynchronous operations. For instance, if you use the <code>superagent</code>
HTTP library to make an HTTP request to Google&#39;s home page, you would use code
similar to what you see below.</p>
<pre><code class="lang-javascript">superagent.get(<span class="hljs-string">'http://google.com'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  <span class="hljs-comment">// Handle error, use res</span>
});
</code></pre>
<p>By yielding asynchronous operations, you can write asynchronous operations
without callbacks. However, remember that a coroutine involves two functions:
the generator function, and the function that calls <code>next()</code> on the generator.
When your generator function yields an asynchronous operation, the calling
function needs to handle the asynchronous operation and resume the generator
when the asynchronous operation completes.</p>
<p>The most popular library for handling generator functions that yield
asynchronous operations is called co. Here&#39;s what getting the HTML for Google&#39;s
home page looks like in co. Looks cool, right? The below code is still
asynchronous, but looks like synchronous code. In this chapter, you&#39;ll learn
about how co works by writing your own co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
});
</code></pre>
<h2 id="promises-and-thunks">Promises and Thunks</h2>
<p>The purpose of this chapter is to build your own co. But first, there&#39;s one
key term that we need to clarify: what sort of asynchronous operations can
you yield to co? The examples you&#39;ve seen so far</p>
<p><br><br><br></p>
<p>in this book have been
cherry-picked. For instance, recall the asynchronous function from the
asynchronous errors section.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>)), <span class="hljs-number">10</span>);
};
</code></pre>
<p>The above function is asynchronous, but not representative of asynchronous
functions as a whole. For instance, the <code>superagent.get</code> function takes
a parameter as well as a callback:</p>
<pre><code class="lang-javascript">superagent.get(<span class="hljs-string">'http://google.com'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
<span class="hljs-comment">// Handle error, use res</span>
});
</code></pre>
<p>The <code>async</code> function is an example of a thunk. A <strong>thunk</strong> is an asynchronous
function that takes a single parameter, a callback. The <code>superagent.get()</code>
function is <em>not</em> a thunk, because it takes 2 parameters, a url and a callback.</p>
<p>Thunks may seem limited, but with arrow functions you can easily convert
any asynchronous function call to a thunk.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> (callback) =&gt; { superagent.get(<span class="hljs-string">'http://google.com'</span>, callback); };
});
</code></pre>
<p>There are also libraries that can convert asynchronous functions to thunks
for you. The original author of co, TJ Holowaychuk, also wrote a library called
thunkify. As the name suggests, thunkify converts a general asynchronous
function into a thunk for use with co. The <code>thunkify</code> function takes a
single parameter, an asynchronous function, and returns a function that
returns a thunk. Below is how you would use
<code>thunkify()</code> with co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
<span class="hljs-keyword">const</span> thunkify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'thunkify'</span>);

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> thunk = thunkify(superagent.get)(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-comment">// function</span>
  <span class="hljs-keyword">typeof</span> thunk;
  <span class="hljs-comment">// A function's length property contains the number of parameters</span>
  <span class="hljs-comment">// In this case, 1</span>
  thunk.length;
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> thunk;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
}).catch(error =&gt; done(error));
</code></pre>
<p><br><br></p>
<p>Thunkify may seem confusing because of the numerous layers of function
indirection. Don&#39;t worry, thunkify is not that complex, you can implement
your own in 9 lines. Below is a simple implementation of thunkify.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

<span class="hljs-keyword">const</span> thunkify = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-comment">// Thunkify returns a function that takes some arguments</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// The function gathers the arguments</span>
    <span class="hljs-keyword">const</span> args = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) {
      args.push(arg);
    }
    <span class="hljs-comment">// And returns a thunk</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-comment">// The thunk calls the original function with your arguments</span>
      <span class="hljs-comment">// plus the callback</span>
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">null</span>, args.concat([callback]));
    };
  };
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> thunk = thunkify(superagent.get)(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-comment">// </span>
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> thunk;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
});
</code></pre>
<p>If thunkify makes thunks so easy, why do you ever need anything else? As is
often the case with JavaScript, the problem is the <code>this</code> keyword.
The below example shows that when you call <code>thunkify()</code> on a function, that
function loses its value of <code>this</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
  <span class="hljs-keyword">async</span>(callback) {
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>);
  }
}

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> test = <span class="hljs-keyword">new</span> Test();
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(test.async)();
  <span class="hljs-comment">// Woops, res refers to global object rather than the `test` variable</span>
  assert.ok(res !== test);
  done();
});
</code></pre>
<p><br><br><br><br></p>
<p>Why does thunkify lose the function&#39;s value of <code>this</code>? Because the JavaScript
language spec treats calling <code>a.b();</code> different from <code>var c = a.b; c();</code>.
When you call a function as a member, like the <code>a.b();</code> case, <code>this</code> will equal
<code>a</code> in the function call. However, <code>var c = a.b; c();</code> does not call a function
as a member, so <code>this</code> refers to the global object in <code>c</code>. The latter case
also applies when you pass a function as a parameter to another function,
like you do with <code>thunkify()</code>.</p>
<p>There are ways to make thunkify work better. For instance, in the previous
example, you could use <code>.bind()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(test.async.bind(test))();
</code></pre>
<p>However, <code>bind()</code> gets to be very confusing when you have <em>chained</em> function
calls. A chained function call takes the form <code>a.b().c().d()</code>, and the <code>b()</code>,
<code>c()</code>, and <code>d()</code> function calls are &quot;chained&quot; together. This API pattern
is often used in JavaScript for building up complex objects, like HTTP requests
or MongoDB queries. For instance, superagent has a chainable API for building
up HTTP requests.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create an arbitrary complex HTTP request to show how superagent's</span>
<span class="hljs-comment">// request builder works.</span>
superagent.
  get(<span class="hljs-string">'http://google.com'</span>).
  <span class="hljs-comment">// Set the HTTP Authorization header</span>
  set(<span class="hljs-string">'Authorization'</span>, <span class="hljs-string">'MY_TOKEN_HERE'</span>).
  <span class="hljs-comment">// Only allow 5 HTTP redirects before failing</span>
  redirects(<span class="hljs-number">5</span>).
  <span class="hljs-comment">// Add `?color=blue` to the URL</span>
  query({ color: blue }).
  <span class="hljs-comment">// Send the request</span>
  end(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{});
</code></pre>
<p>Let&#39;s say you wanted to thunkify the above code. Where would you need to use
<code>.bind()</code> and what would you need to <code>bind()</code> to? The answer is not obvious
unless you read superagent&#39;s code. You need to <code>bind()</code> to
the return value of <code>superagent.get()</code>.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> req = superagent.get(<span class="hljs-string">'http://google.com'</span>);
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(req.query({ color: blue }).end.bind(req));
});
</code></pre>
<p>Thunkify and thunks in general are an excellent fallback, but co
supports a better asynchronous primitive: promises. A <strong>promise</strong> is an
object that has a <code>.then()</code> function that takes two functions as parameters.</p>
<ul>
<li><code>onFulfilled</code>: called if the asynchronous operation succeeds.</li>
<li><code>onRejected</code>: called if the asynchronous operation failed.</li>
</ul>
<p><br><br><br><br></p>
<p>You can think of promises as an object wrapper around a single
asynchronous operation. Once you call <code>.then()</code>, the asynchronous
operation starts. Once the asynchronous operation completes,
the promise then calls either <code>onFulfilled</code> or <code>onRejected</code>.</p>
<p>For example, each function call in the superagent
HTTP request builder returns a promise that you can <code>yield</code>.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// `superagent.get()` returns a promise, because the `.then` property</span>
  <span class="hljs-comment">// is a function.</span>
  superagent.get(<span class="hljs-string">'http://www.google.com'</span>).then;
  co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Works because co is smart enough to look for a `.then()` function</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> superagent.
      get(<span class="hljs-string">'http://www.google.com'</span>).
      query({ color: <span class="hljs-string">'blue'</span> });
  });
});
</code></pre>
<p>Much easier than using thunkify! More importantly, you don&#39;t have to worry
about messing up the value of <code>this</code> because you aren&#39;t passing a function as
a parameter. The downside of promises, though, is that you rely on the function
itself to return a promise. When you use thunkify, you make no assumptions
about the return value of the function you&#39;re calling. However, many popular
Node.js libraries, like superagent, the redis driver, and the MongoDB driver,
all have the ability to return promises for asynchronous operations.</p>
<p>Creating your own promises is easy. Promises are a core part of ES2015, so
you don&#39;t have to include any libraries. Below is an example of how to create
an ES2015 promise. The <code>Promise</code> constructor takes a single function,
called a <strong>resolver</strong>, which takes two function parameters, <code>resolve</code> and
<code>reject</code>. The resolver is responsible for executing the asynchronous
operation and calling <code>resolve()</code> if the operation succeeded or <code>reject()</code>
if it failed.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// The resolver function takes 2 parameters, a `resolve()` function</span>
<span class="hljs-comment">// and a `reject()` function.</span>
<span class="hljs-keyword">const</span> resolver = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-comment">// Call `resolve()` asynchronously with a value</span>
  setTimeout(() =&gt; resolve(<span class="hljs-string">'Hello, World!'</span>), <span class="hljs-number">5</span>);
};
<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolver);
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>{
  <span class="hljs-comment">// The promise's `onFulfilled` function gets called with</span>
  <span class="hljs-comment">// the value the resolver passed to `resolve()`. In this</span>
  <span class="hljs-comment">// case, the string 'Hello, World!'</span>
  res;
});
</code></pre>
<p><br><br><br><br><br></p>
<p>Promises are a deep subject and what you&#39;ve seen thus far is just the tip of
the iceberg. To use co, all you need to know is that
a promise is an object with a <code>.then()</code> function that takes 2 function
parameters: <code>onFulfilled</code> and <code>onRejected</code>. For instance, below is an example
of a minimal promise that&#39;s compatible with co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> promise = {
  then: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>{
    setTimeout(() =&gt; onFulfilled(<span class="hljs-string">'Hello, World!'</span>), <span class="hljs-number">0</span>);
  }
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">yield</span> promise;
  assert.equal(str, <span class="hljs-string">'Hello, World!'</span>);
});
</code></pre>
<h2 id="write-your-own-co">Write Your Own Co</h2>
<p>Now that you&#39;ve seen how thunks and promises work, it&#39;s time to apply the
fundamentals of generators to write your own minimal implementation of co.
To avoid confusion, your version will be called &quot;fo&quot; (pronounced like &quot;faux&quot;).</p>
<p>The v1 implementation of fo is short, but will utilize all the concepts that
you&#39;ve learned thus far. You&#39;ll use generator functions, <code>generator.next()</code>,
<code>generator.throw()</code>, thunks, and promises. Ready? The
implementation is...</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">generatorFunction</span>) </span>{
  <span class="hljs-keyword">const</span> generator = generatorFunction();
  next();

  <span class="hljs-comment">// Call next() or throw() on the generator as necessary</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">v, isError</span>) </span>{
    <span class="hljs-keyword">const</span> res = isError ? generator.throw(v) : generator.next(v);
    <span class="hljs-keyword">if</span> (res.done) {
      <span class="hljs-keyword">return</span>;
    }
    handleAsync(res.value);
  }

  <span class="hljs-comment">// Handle the result the generator yielded</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAsync</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">async</span> &amp;&amp; <span class="hljs-keyword">async</span>.then) {
      handlePromise(<span class="hljs-keyword">async</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">async</span> === <span class="hljs-string">'function'</span>) {
      handleThunk(<span class="hljs-keyword">async</span>);
    } <span class="hljs-keyword">else</span> {
      next(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid yield <span class="hljs-subst">${async}</span>`</span>), <span class="hljs-literal">true</span>);
    }
  }

  <span class="hljs-comment">// If the generator yielded a promise, call `.then()`</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">async</span>.then(next, (error) =&gt; next(error, <span class="hljs-literal">true</span>));
  }

  <span class="hljs-comment">// If the generator yielded a thunk, call it</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleThunk</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">async</span>((error, v) =&gt; {
      error ? next(error, <span class="hljs-literal">true</span>) : next(v);
    });
  }
};

<span class="hljs-comment">// fo in action</span>
fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
});
</code></pre>
<p><br><br><br></p>
<p>Let&#39;s take a closer look at how the <code>fo()</code> function works. The first step is
to create a generator from the provided generator function. Once you have
a generator, you need to use the <code>next()</code> function to kick off the generator&#39;s
execution. The <code>next()</code> function calls <code>generator.next()</code> to start off the
generator. Any time the generator yields, the <code>fo()</code> function calls
<code>handleAsync()</code>, which is responsible for handling the asynchronous operations
the generator yields. In particular, <code>handlePromise()</code> handles any promises
that the generator yields, and <code>handleThunk()</code> handles any thunks.</p>
<p>Let&#39;s see how <code>fo()</code> works with a simple error. In the below example, you make
an HTTP request to a nonexistent URL. Superagent will fail, and so the
promise calls its <code>onRejected()</code> function. The <code>fo()</code> function will then call
<code>next()</code> with <code>isError</code> set to true. The internal <code>next()</code> function then
calls <code>generator.throw()</code> to trigger an error in the generator, which you
can then try/catch.</p>
<pre><code class="lang-javascript">fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// First iteration of `next()` stops here,</span>
    <span class="hljs-comment">// calls `.then()` on the promise</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://doesnot.exist.baddomain'</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// The promise was rejected, so fo calls `generator.throw()` and</span>
    <span class="hljs-comment">// you end up here.</span>
  }

  <span class="hljs-comment">// Second iteration of `next()` stops here, `.then()` on the promise</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  res.text;
  <span class="hljs-comment">// Third iteration of `next()` stops here because generator is done</span>
});
</code></pre>
<p>One neat pattern that illustrates the power of asynchronous coroutines is
retrying failed HTTP requests. If the server you&#39;re trying to reach is
unreliable, you may want to retry requests a fixed number of times before
giving up. Without generators, retrying requests involves a lot of recursion
and careful design decisions.
With generators and <code>fo()</code> (or co), all you need to retry requests
is a for loop as shown below.</p>
<pre><code class="lang-javascript">fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">'http://doesnot.exist.baddomain'</span>;
  <span class="hljs-keyword">const</span> NUM_RETRIES = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">let</span> res;
  <span class="hljs-keyword">let</span> i;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Going to yield 3 times, and `fo()` will call `generator.throw()`</span>
      <span class="hljs-comment">// 3 times because superagent will fail every time</span>
      res = <span class="hljs-keyword">yield</span> superagent.get(url);
    } <span class="hljs-keyword">catch</span> (error) { <span class="hljs-comment">/* retry */</span> }
  }
  <span class="hljs-comment">// res is undefined - retried 3 times with no results</span>
});
</code></pre>
<h2 id="limitations">Limitations</h2>
<p>The v1 implementation of fo is simple, clean, and gets you 80% of the way
to writing your own co. However, co has several subtle features that become
indispensable when you try to write a real application.</p>
<p>One particular edge case that we glossed over in the &quot;Write Your Own Co&quot;
section is what happens when there&#39;s an uncaught error in the generator.
In the v1 implementation of fo, the uncaught error will crash the process.
Crashing the process isn&#39;t the worst possible behavior, but, as you&#39;ll see in
the &quot;Real Implementation of Co&quot; section, co provides a neat way to catch
any uncaught errors in the generator function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">try</span> {
  fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// This will throw an uncaught asynchronous exception</span>
    <span class="hljs-comment">// and crash the process!</span>
    <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://doesnot.exist.baddomain'</span>);
  });
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-comment">// This try/catch won't catch the error within the `fo()` call!</span>
}
</code></pre>
<p>Another limitation is the ability to use helper functions that yield. For
instance, suppose you wanted to write a <code>retry()</code> helper function that
retried an asynchronous operation a fixed number of times for you.
You might try implementing retry as a plain old function
(as opposed to a generator function) and then quickly realize that you can&#39;t
yield from a normal function. You might then try implementing
the <code>retry()</code> function as shown below. But alas! Your <code>fo()</code> v1 doesn&#39;t
supporting yielding generators! </p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Needs to be a generator function so you can `yield` in it.</span>
<span class="hljs-keyword">const</span> retry = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">fn, numRetries</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numRetries; ++i) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> fn();
      <span class="hljs-keyword">return</span> res;
    } <span class="hljs-keyword">catch</span> (error) {}
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Retried <span class="hljs-subst">${numRetries}</span> times`</span>);
};

fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">'http://www.google.com'</span>;
  <span class="hljs-comment">// Fo's `handleAsync` function will throw because you're</span>
  <span class="hljs-comment">// yielding a generator function!</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> retry(() =&gt; superagent.get(url), <span class="hljs-number">3</span>);
});
</code></pre>
<p><br><br><br><br></p>
<p>Finally, fo v1 doesn&#39;t allow any parallelism. Asynchronous operations must
be executed one after the other, there&#39;s no way to execute 2 requests in
parallel. Suppose you wanted to load Google and Amazon&#39;s home pages in parallel
as shown below. As you&#39;ll see in the &quot;Real Implementation of Co&quot; section,
co gives you a convenient mechanism to execute requests in
parallel.</p>
<pre><code class="lang-javascript">fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> google = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-keyword">const</span> amazon = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.amazon.com'</span>);
});
</code></pre>
<h2 id="real-implementation-of-co">Real Implementation of Co</h2>
<p>The key decision that makes co 4.x overcome all the limitations of fo v1 is
that the <code>co()</code> function itself returns a promise, and converts all
asynchronous operations into promises. If fo() returns a promise, then you
can handle the case where the generator yields a generator function by just
calling fo() on the yielded generator function. Promises also provide a
mechanism for handling errors: the <code>reject()</code> function. You can wrap your
calls to <code>generator.next()</code> and <code>generator.throw()</code> in a try/catch, and reject
the promise if the generator threw. Below is the implementation of fo v2,
which uses promises internally and returns a promise.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>{
  <span class="hljs-keyword">const</span> isGenerator = (v) =&gt; <span class="hljs-keyword">typeof</span> v.next === <span class="hljs-string">'function'</span>;
  <span class="hljs-keyword">const</span> isGeneratorFunction =
    (v) =&gt; v.constructor &amp;&amp; v.constructor.name === <span class="hljs-string">'GeneratorFunction'</span>;

  <span class="hljs-keyword">let</span> generator;
  <span class="hljs-keyword">if</span> (isGenerator(input)) generator = input;
  <span class="hljs-keyword">if</span> (isGeneratorFunction(input)) generator = input();
  <span class="hljs-keyword">if</span> (!generator) <span class="hljs-keyword">throw</span> <span class="hljs-string">`Invalid parameter to fo() <span class="hljs-subst">${input}</span>`</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
    next();

    <span class="hljs-comment">// Call next() or throw() on the generator as necessary</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">v, isError</span>) </span>{
      <span class="hljs-keyword">let</span> res;
      <span class="hljs-keyword">try</span> {
        res = isError ? generator.throw(v) : generator.next(v);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">return</span> reject(error);
      }
      <span class="hljs-keyword">if</span> (res.done) {
        <span class="hljs-keyword">return</span> resolve(res.value);
      }
      toPromise(res.value).then(next, (error) =&gt; next(error, <span class="hljs-literal">true</span>));
    }

    <span class="hljs-comment">// Convert v to a promise. If invalid, returns a rejected promise</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toPromise</span>(<span class="hljs-params">v</span>) </span>{
      <span class="hljs-keyword">if</span> (isGeneratorFunction(v) || isGenerator(v)) <span class="hljs-keyword">return</span> fo(v);
      <span class="hljs-keyword">if</span> (v.then) <span class="hljs-keyword">return</span> v;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
          v((error, res) =&gt; error ? reject(error) : resolve(res));
        });
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(v)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(v.map(toPromise));
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid yield <span class="hljs-subst">${v}</span>`</span>));
    }
  });
};
</code></pre>
<p><br><br></p>
<p>Let&#39;s take a look at how this new version of fo resolves the major limitations
of the first version. First off, let&#39;s take a look at error handling. The key
idea for error handling in fo is the below code.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> res;
<span class="hljs-keyword">try</span> {
  res = isError ? generator.throw(v) : generator.next(v);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-keyword">return</span> reject(error);
}
</code></pre>
<p>The <code>fo()</code> function may be asynchronous, but every error that can occur in your
generator function happens synchronously in the above try block. For instance,
suppose you made an HTTP request to a bad URL and didn&#39;t wrap your
<code>superagent.get()</code> call in a try/catch. In that case, fo will reject the
promise and trigger your <code>onRejected</code> handler.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://doesnot.exist.baddomain'</span>);
}).then(<span class="hljs-literal">null</span>, (error) =&gt; {
  <span class="hljs-comment">// Caught the HTTP error!</span>
});
</code></pre>
<p>ES2015 promises have a handy helper function called <code>.catch()</code>. While <code>catch()</code>
may sound intimidating, it is just a convenient shorthand for <code>.then()</code> with
no <code>onFulfilled</code> handler. In other words using <code>.catch()</code> as shown below:</p>
<pre><code class="lang-javascript">promise.catch(errorHandler);
</code></pre>
<p>is just a convenient shorthand for the below code.</p>
<pre><code class="lang-javascript">promise.then(<span class="hljs-literal">null</span>, errorHandler);
</code></pre>
<p>Below is the previous example re-written to use <code>.catch()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://doesnot.exist.baddomain'</span>);
}).catch((error) =&gt; {
  <span class="hljs-comment">// Caught the HTTP error!</span>
});
</code></pre>
<p><br><br><br><br><br><br></p>
<p>Fo&#39;s error handling abilities aren&#39;t limited to asynchronous errors. Since you
wrapped <code>generator.next()</code> in a try/catch, fo reports <strong>any</strong> uncaught errors
that occur when executing the generator to your <code>onRejected</code> handler. For
instance, say you accidentally access a nonexistent property and get the
dreaded <code>TypeError: Cannot read property &#39;X&#39; of undefined</code> error. Fo will
report that error to <code>onRejected</code> as well!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-comment">// Throws a TypeError, because `html.notARealProperty` is undefined</span>
  <span class="hljs-keyword">const</span> v = html.notARealProperty.test;
}).catch((error) =&gt; {
  <span class="hljs-comment">// Caught the TypeError!</span>
});
</code></pre>
<p>The new implementation of fo also enables you to yield generators and
generator functions. Since <code>fo()</code> returns a promise, all you need to do is
detect when the generator yields another generator and use <code>fo()</code> to convert
that generator to a promise. Fo v2 uses the below functions <code>isGenerator()</code>
and <code>isGeneratorFunction()</code> to determine if the yielded value is a generator
or generator function, respectively.</p>
<p>Co also has similar helper functions, however, co&#39;s checks are more robust.
These functions are meant to be examples, don&#39;t use them in production!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> isGenerator = (v) =&gt; <span class="hljs-keyword">typeof</span> v.next === <span class="hljs-string">'function'</span>;
<span class="hljs-keyword">const</span> isGeneratorFunction =
  (v) =&gt; v.constructor &amp;&amp; v.constructor.name === <span class="hljs-string">'GeneratorFunction'</span>;
</code></pre>
<p>Now that you can check if a value is a generator or a generator function,
the <code>toPromise()</code> function can call <code>fo()</code> recursively to convert the
generator you yielded into a promise.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Convert v to a promise. If invalid, returns a rejected promise</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toPromise</span>(<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">if</span> (isGeneratorFunction(v) || isGenerator(v)) <span class="hljs-keyword">return</span> fo(v);
}
</code></pre>
<p>And now, you can write helper functions that can yield, as long as the helper
function is a generator function too.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> get = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
};
<span class="hljs-comment">// fo v2 in action. Note that you're yielding a generator!</span>
fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Get the HTML for Google's home page</span>
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> get();
}).catch((error) =&gt; done(error));
</code></pre>
<p><br></p>
<p>This new version of fo also enables you to execute requests in parallel.
If you yield an array, fo will execute the array elements in parallel and
return the results as an array. The magic that makes this work is the
<code>toPromise()</code> function&#39;s array handler.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Convert v to a promise. If invalid, returns a rejected promise</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toPromise</span>(<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">if</span> (isGeneratorFunction(v) || isGenerator(v)) <span class="hljs-keyword">return</span> fo(v);
  <span class="hljs-keyword">if</span> (v.then) <span class="hljs-keyword">return</span> v;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
      v((error, res) =&gt; error ? reject(error) : resolve(res));
    });
  }
  <span class="hljs-comment">// Magic array handler</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(v)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(v.map(toPromise));
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid yield <span class="hljs-subst">${v}</span>`</span>));
}
</code></pre>
<p>The <code>Promise.all()</code> function is yet another new feature in the ES2015 spec.
The <code>Promise.all()</code> function takes an array of promises and converts them
into a single promise. The <code>Promise.all()</code> promise&#39;s <code>onFulfilled</code> function
gets called when every promise in the array is resolved, and its
<code>onRejected</code> function gets called whenever any of the promises in the array
is rejected.</p>
<p>When your generator function yields an array, the <code>toPromise()</code> function first
uses <code>.map()</code> to convert every element in the array to a promise, and then
passes that array to <code>Promise.all()</code>. This means that the HTTP requests below
execute in parallel.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Parallel HTTP requests!</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> [
        superagent.get(<span class="hljs-string">'http://www.google.com'</span>),
        superagent.get(<span class="hljs-string">'http://www.amazon.com'</span>)
      ];
});
</code></pre>
<p>Congratulations, you&#39;ve successfully implemented your own co knockoff!
Co supports all the features of fo, plus a few extra. Go take a look at
the source code for co 4.x on GitHub, it should now look familiar. Don&#39;t
forget the following key points for working with co.</p>
<ul>
<li>Error handling. Make sure to use <code>co().catch()</code>, this will enable you to
catch all errors that occur in your generator function, not just promise
rejections.</li>
<li>Parallelism. Running requests in parallel with co is as simple as yielding
an array. Using parallel requests where possible can give you a big performance
boost.</li>
<li>Internal error handling. If you don&#39;t want an error to stop execution of your
generator function, use try/catch. With co, you can use try/catch to handle
asynchronous errors.</li>
<li>Helper functions. Helper functions can be generator functions as well, just
be sure to use yield.</li>
</ul>
<p><br><br><br></p>
<p>Below is an example of some of the above points in action.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> res;
  <span class="hljs-keyword">try</span> {
    res = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    res = getCached();
  }

  <span class="hljs-comment">// Any errors with this get sent to handleError</span>
  <span class="hljs-comment">// The `persistToDb()` function is a generator function.</span>
  <span class="hljs-keyword">yield</span> persistToDb(res.text);
}).catch(handleError);
</code></pre>
<h1 id="chapter-3-koa-and-middleware">Chapter 3: Koa and Middleware</h1>
<p>Co and the notion of asynchronous coroutines enable you to write asynchronous
code with cleaner syntax. However, co is useful for more than just writing
HTTP requests without callbacks. As you saw in the &quot;Real Implementation of Co&quot;
section, co supports generators as an asynchronous primitive. You used this
idea to write helper functions that were also generators. The idea of yielding
generators is useful for composing asynchronous functions, which leads to the
idea of middleware.</p>
<p>The concept of <strong>middleware</strong> in JavaScript is a sequence of functions where
one function is responsible for calling the next function in the sequence.
Conventional ES5-style middleware has the below form.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> middlewareFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
  <span class="hljs-comment">// A middleware function takes in the request and response,</span>
  <span class="hljs-comment">// transforms them, and calls `next()` to trigger the next</span>
  <span class="hljs-comment">// function in the middleware chain.</span>
  next();
};
</code></pre>
<p>However, this function composition paradigm has numerous limitations. Once a
middleware function calls <code>next()</code>, it defers control to the next function
in the sequence. There is no way for the next function to return any values
or defer control back to the previous middleware. In other words, what if
you wanted to write a middleware function that reported how long the
rest of the sequence of functions took to complete?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> middlewareFn = (req, res, next) =&gt; {
  <span class="hljs-comment">// next() is async and does not return a promise, nor does it</span>
  <span class="hljs-comment">// take a callback.</span>
  next();
};
</code></pre>
<p>The <code>next()</code> call fires off the next middleware in the chain, but there is no
way for the middleware function above to know when <code>next()</code> is done.
However, suppose your middleware functions were generator functions rather
than regular functions, and suppose <code>next()</code> returned a promise. If you
wrapped the middleware generator functions in a <code>co()</code> call, you would now
have the ability to compose asynchronous coroutines: the first coroutine calls
the second and so on, and then the first coroutine picks up where it left off
after the second is done.</p>
<p><br><br><br><br><br><br><br><br><br></p>
<p>The generator-based function composition library koa-compose does exactly
this. The <code>next</code> parameter is a generator function that triggers the next
generator in the sequence. In the below example, <code>middleware1</code> yields
next to defer control to <code>middleware2</code>, which takes approximately 100ms
to run, and picks up where it left off after <code>middleware2</code> is done.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-compose'</span>);

<span class="hljs-keyword">const</span> middleware1 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">yield</span> next;
  <span class="hljs-comment">// Approximately 100</span>
  <span class="hljs-keyword">const</span> end = <span class="hljs-built_in">Date</span>.now() - start;
};

<span class="hljs-keyword">const</span> middleware2 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// Yield a thunk that gets resolved after 100 ms</span>
  <span class="hljs-keyword">yield</span> callback =&gt; setTimeout(() =&gt; callback(), <span class="hljs-number">100</span>);
  <span class="hljs-keyword">yield</span> next;
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> compose([middleware1, middleware2])();
});
</code></pre>
<h2 id="the-koa-compose-module">The koa-compose Module</h2>
<p>The koa-compose module that you saw in this chapter&#39;s introduction is trivial
to implement. The key idea is that the <code>next</code> generator function that each
middleware gets is a generator which, when completed, means that each
subsequent middleware has completed. In other words, the <code>next</code> parameter
to each generator function needs to be a generator derived from the next
generator function in the sequence as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middleware</span>) </span>{
  <span class="hljs-keyword">const</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{};
  <span class="hljs-comment">// compose returns a generator</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> i = middleware.length;
    <span class="hljs-keyword">let</span> next = noop;
    <span class="hljs-keyword">while</span> (i--) {
      <span class="hljs-comment">// Loop over generators from last to first. The `next` passed</span>
      <span class="hljs-comment">// to the i-th generator function is the (i+1)-th generator.</span>
      next = middleware[i](next);
    }
    <span class="hljs-keyword">yield</span> next;
  };
};
</code></pre>
<p><br><br></p>
<p>The real implementation of koa-compose is almost identical to the above
implementation, just with better support for the <code>this</code> keyword. The <code>this</code>
keyword will be important in the koa section. But, before you learn about koa,
let&#39;s take a look at how error handling works in koa-compose.</p>
<p>Remember that koa-compose doesn&#39;t add any special error handling on top of
co and generators. If the first middleware in the chain throws an error,
the subsequent middleware functions never execute, and the <code>yield</code> statement
that calls the composed function will throw an error.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-compose'</span>);

<span class="hljs-keyword">const</span> middleware1 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>);
};

<span class="hljs-keyword">const</span> middleware2 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// never get here</span>
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This will throw an error</span>
  <span class="hljs-keyword">yield</span> compose([middleware1, middleware2])();
}).catch(error =&gt; {
  <span class="hljs-comment">// Error: oops</span>
});
</code></pre>
<p>One neat feature of this middleware paradigm is that you can define error
handling middleware using try/catch. Since the way you defer control to the
next generator function in the sequence is by yielding on a generator,
surrounding the <code>yield next</code> call in a try/catch will catch <strong>any</strong> errors
that the subsequent functions in the sequence throw.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> error;
<span class="hljs-keyword">const</span> middleware1 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// The `middleware2` generator function throws...</span>
    <span class="hljs-keyword">yield</span> next;
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// which triggers this try/catch and records the error</span>
    error = err;
  }
};

<span class="hljs-keyword">const</span> middleware2 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Will get caught'</span>);
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// `res` will be -1 since the final value returned by middleware1</span>
  <span class="hljs-comment">// is -1</span>
  <span class="hljs-keyword">yield</span> compose([middleware1, middleware2])();
  <span class="hljs-comment">// error is now 'Error: Will get caught'</span>
});
</code></pre>
<h2 id="the-koa-web-framework">The Koa Web Framework</h2>
<p>The most important application of koa-compose and generator-based middleware
is a web framework called koa. Koa is a thin layer on top of koa-compose that
makes it easier to write web servers using generator-based middleware. The
below example creates a koa HTTP server that displays &quot;Hello, World!&quot; when
you open <code>http://localhost:3000</code> in a browser.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-comment">// Create a new koa app</span>
<span class="hljs-keyword">const</span> app = koa();
<span class="hljs-comment">// Each app has its own sequence of middleware. The `.use()`</span>
<span class="hljs-comment">// function adds a generator function to the middleware chain.</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// `superagent.get('http://localhost:3000');` will now</span>
  <span class="hljs-comment">// return 'Hello, World!'</span>
  <span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Hello, World!'</span>;
});
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p>The goal of this section is to write your own minimal take on koa. Koa is just
a thin layer on top of koa-compose with some HTTP-specific syntactic sugar.
Recall that koa-compose retains the same <code>this</code> across all middleware functions.
In order to craft a response to an incoming HTTP request, koa requires you to
set properties on <code>this</code>, also known as the koa <strong>context</strong>.</p>
<p>Before you implement your own minimal koa, there&#39;s a couple key concepts you
should be aware of. First, generator functions have a context
(the value of the <code>this</code> keyword) just like
regular JavaScript functions. The easiest way to call a generator with a
pre-defined value of <code>this</code> is the <code>call()</code> function defined on every JavaScript
function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Will print 'Hello, World!'</span>
  <span class="hljs-keyword">yield</span> generatorFunction.call(<span class="hljs-string">'Hello, World!'</span>);
});
</code></pre>
<p>The other key concept is the Node.js HTTP package. The ability to start an
HTTP server is part of core Node.js. Here&#39;s how you would start an HTTP server
on port 3000 that prints out &quot;Hello, World!&quot; as a response to every request.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-comment">// Create a new server with a request handler. `req` represents</span>
<span class="hljs-comment">// the request, and `res` represents the response.</span>
<span class="hljs-keyword">const</span> server = http.createServer((req, res) =&gt; res.end(<span class="hljs-string">'Hello, World!'</span>));
<span class="hljs-comment">// Listen on port 3000</span>
server.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p><br><br></p>
<p>The downside of Node.js&#39; vanilla HTTP package is that it doesn&#39;t provide an
easy way to compose request handlers. You pass <code>createServer()</code> a function
that takes in a request and a response, and you&#39;re responsible for figuring
out what that function should be. Koa enables you to use koa-compose to compose
generator functions into a route handler that&#39;s compatible with Node.js&#39; HTTP
server package. With that in mind, below is a minimal implementation of koa
that is sufficient to run your basic &quot;Hello, World&quot; example.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-compose'</span>);

<span class="hljs-comment">// The minimal koa implementation</span>
<span class="hljs-keyword">const</span> koa = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// List of middleware</span>
  <span class="hljs-keyword">let</span> middleware = [];

  <span class="hljs-comment">// The real work is in this function, which creates the</span>
  <span class="hljs-comment">// actual HTTP server</span>
  <span class="hljs-keyword">const</span> listen = (port) =&gt; {
    <span class="hljs-comment">// First, koa-compose all the middleware together</span>
    <span class="hljs-keyword">const</span> composedMiddleware = compose(middleware);
    <span class="hljs-comment">// Create a server with a co-based request handler</span>
    <span class="hljs-keyword">const</span> server = http.createServer((req, res) =&gt; {
      co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">const</span> context = {};
        <span class="hljs-comment">// Execute all the middleware using the empty context object</span>
        <span class="hljs-keyword">yield</span> composedMiddleware.call(context);
        <span class="hljs-comment">// Once the middleware is done, send the request body</span>
        res.end(context.body);
      });
    });
    <span class="hljs-keyword">return</span> server.listen(port);
  };

  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// The `use()` function just adds a new generator function to</span>
    <span class="hljs-comment">// the list of middleware</span>
    use: (middlewareFn) =&gt; middleware.push(middlewareFn),
    listen: listen
  };
};

<span class="hljs-comment">// Create a new koa app</span>
<span class="hljs-keyword">const</span> app = koa();
<span class="hljs-comment">// Each app has its own sequence of middleware. The `.use()`</span>
<span class="hljs-comment">// function adds a generator function to the middleware chain.</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// `superagent.get('http://localhost:3000');` will now</span>
  <span class="hljs-comment">// return 'Hello, World!'</span>
  <span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Hello, World!'</span>;
});
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p><br><br></p>
<p>The real implementation of koa includes many more features, but the fundamental
idea is similar to the previous implementation. In particular, the request
handler koa 1.x passes to the Node.js <code>http.createServer()</code> function is just
the result of running koa-compose on the app&#39;s middleware plus
post-processing to translate the <code>context</code> object into an HTTP response.</p>
<p>For instance, the real implementation of koa exposes the request and response
objects on the request context. In the minimal koa implementation, your
middleware doesn&#39;t know anything about incoming requests, which makes it
impossible to craft a real response. Supporting
this feature would look like what you see below.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a server with a co-based request handler</span>
<span class="hljs-keyword">const</span> server = http.createServer((req, res) =&gt; {
  co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Expose req and res by default</span>
    <span class="hljs-keyword">const</span> context = { req: req, res: res };
    <span class="hljs-comment">// Execute all the middleware using the empty context object</span>
    <span class="hljs-keyword">yield</span> composedMiddleware.call(context);
    <span class="hljs-comment">// Once the middleware is done, send the request body</span>
    res.end(context.body);
  });
});
</code></pre>
<p>Koa&#39;s middleware approach has some neat features. For instance, it is difficult
to define a catch-all error handler in web frameworks like Express. However, in
koa, defining an error handler is a trivial application of try/catch.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
<span class="hljs-keyword">const</span> app = koa();

<span class="hljs-comment">// The first middleware is an error handler: if any subsequent</span>
<span class="hljs-comment">// middleware throws an error, this try/catch will handle it.</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> next;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">this</span>.body = error.toString();
    <span class="hljs-keyword">this</span>.status = <span class="hljs-number">500</span>;
  }
});

<span class="hljs-comment">// So if google.com is down, this middleware will throw an error,</span>
<span class="hljs-comment">// and the above middleware will report it as an HTTP 500.</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">this</span>.body = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
  <span class="hljs-keyword">yield</span> next;
});

<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<h2 id="limitations-of-koa-compose-and-koa">Limitations of koa-compose and Koa</h2>
<p>Koa and koa-compose are powerful tools, but they are far from perfect. At the
time of this writing, koa 2 is in alpha release and completely breaks the
koa 1 API that you learned about in the koa section. Koa 1 also supports
the composition module as a replacement for koa-compose. What&#39;s the issue
with koa-compose? One issue with koa-compose is that it doesn&#39;t properly
support returning values from middleware. This is a minor issue, which is why koa
v2 drops support for composition and uses koa-compose.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-compose'</span>);

<span class="hljs-keyword">const</span> middleware1 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> next;
  <span class="hljs-keyword">return</span> res + <span class="hljs-string">'World!'</span>;
};

<span class="hljs-keyword">const</span> middleware2 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, '</span>;
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> compose([middleware1, middleware2])();
  <span class="hljs-comment">// res is undefined!</span>
});
</code></pre>
<p>Koa 1.x has several limitations. In this section, you&#39;ll learn about 2
common complaints about koa 1.x that are resolved in koa 2.x.</p>
<p>The first limitation is that the entire API for structuring your HTTP response
is based on generators. As a matter of fact, if you pass anything other
than a generator function to <code>app.use()</code>, koa will throw an error.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = koa();
<span class="hljs-comment">// Throws 'AssertionError: app.use() requires a generator function'</span>
app.use(() =&gt; { <span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Hello, World'</span> });
<span class="hljs-comment">// Throws 'AssertionError: app.use() requires a generator function'</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Hello, World'</span> });
</code></pre>
<p>Generators are a powerful feature, but not right for all use cases. For
instance, the upcoming ES2016 JavaScript language standard will support the
<code>async</code> and <code>await</code> keywords, which will enable you to write asynchronous
code without callbacks in the same way that <code>co</code> and <code>yield</code> do. Also, since
ES5 doesn&#39;t support generators, running koa in ES5 environments is difficult.</p>
<p>The way that koa 2.x works around this limitation is similar to the approach
you used to overcome the limitations of your minimal v1 implementation of co:
just use promises for everything.</p>
<p><br><br><br></p>
<p>In koa 2.x, the <code>next</code> parameter to your
middleware is not a generator function: it&#39;s a plain-old function that returns
a promise.</p>
<pre><code class="lang-javascript">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx, next</span>) </span>{
  next().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>{
    <span class="hljs-comment">// Executed after the rest of the middleware is done</span>
    ctx.body = <span class="hljs-string">'Hello, World!'</span>;
  });
});
</code></pre>
<p>In addition to co, promises work with the ES2016 <code>async</code> and <code>await</code>
keywords and are usable in ES5.</p>
<p>The above example also hints at the second limitation of koa 1.x: relying
on the <code>this</code> keyword. The <code>this</code> keyword is notorious for making JavaScript
beginners&#39; lives difficult. Instead of using <code>this</code>, koa 2.x passes a
&#39;context&#39; parameter (commonly abbreviated <code>ctx</code>) as the first parameter to
your middleware function. The koa 2.x <code>ctx</code> parameter is analogous to the
koa 1.x <code>this</code> keyword.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> app = koa();
<span class="hljs-comment">// In koa 2.x, you can use arrow functions as middleware</span>
app.use((ctx) =&gt; {
  ctx.body = <span class="hljs-string">'Hello, World!'</span>;
});
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<h1 id="chapter-4-transpiling">Chapter 4: Transpiling</h1>
<p>The last step on your journey to mastering generators is to learn how
to transpile generators into ES5. A <strong>transpiler</strong> compiles one JavaScript
dialect into another JavaScript dialect. In this chapter, you&#39;ll write a
rudimentary transpiler that converts generator functions into plain-old
JavaScript functions.</p>
<p>Parsing JavaScript is complex, however, learning how
generators work in terms of ES5 JavaScript will test the limits of your
knowledge of generator fundamentals. In order to get some insight into how
to compile generators into ES5, you&#39;ll first learn about regenerator, Facebook&#39;s
open-source transpiler for transforming generator functions into ES5.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> regenerator = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regenerator'</span>);

<span class="hljs-keyword">const</span> code = regenerator.compile(<span class="hljs-string">`
  const generatorFunction = function*() {
    yield 'Hello, World!';
  };`</span>).code;

<span class="hljs-comment">// Given the above simple generator function, regenerator will produce</span>
<span class="hljs-comment">// the below code.</span>
assert.equal(code, <span class="hljs-string">`
  var generatorFunction = regeneratorRuntime.mark(function callee$0$0() {
    return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
      while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return 'Hello, World!';
      case 2:
      case "end":
        return context$1$0.stop();
      }
    }, callee$0$0, this);
  });`</span>);
</code></pre>
<h2 id="introducing-regenerator">Introducing Regenerator</h2>
<p>Regenerator is a transpiler: it takes some JavaScript code as a string, and
produces some equivalent JavaScript code as a string. When writing a transpiler,
the two key questions are:</p>
<ol>
<li>What code do you want to transform?</li>
<li>What do you want to transform the code into?</li>
</ol>
<p>In regenerator&#39;s case, the first question is simple: you want to transform
every generator function <code>function*() {}</code> and every <code>yield</code> statement within a
generator function. The second question is more subtle.</p>
<p><br></p>
<p>The ES2015 spec defines
a generator solely in terms of which properties it has. In other words, any
JavaScript object can be a generator, not just the return value of a generator
function. When it comes to JavaScript language APIs, the letter of the law
is vastly more important than the spirit of the law. Any JavaScript object
with a <code>next()</code> function and a <code>throw()</code> function is a generator as far as
co is concerned. For example, if you have an object with a <code>next()</code> function
that returns a promise like you see below, co will still recognize it as a
generator. Note that there are no <code>function*()</code> definitions.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

<span class="hljs-comment">// `plainFunction` is **not** a generator function because</span>
<span class="hljs-comment">// it isn't declared with `function*() {}`. However, it returns</span>
<span class="hljs-comment">// an object that qualifies as a generator.</span>
<span class="hljs-keyword">var</span> plainFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// `next()` and `throw()` are the only properties necessary for</span>
    <span class="hljs-comment">// an object to qualify as a generator.</span>
    next: () =&gt; {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// Note that this generator's `next()` returns a promise</span>
        value: superagent.get(<span class="hljs-string">'http://www.google.com'</span>),
        done: <span class="hljs-literal">true</span>
      };
    },
    <span class="hljs-comment">// `throw()` doesn't get used in this example</span>
    <span class="hljs-keyword">throw</span>: (error) =&gt; {
      <span class="hljs-keyword">throw</span> error;
    }
  };
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// You can use the fake generator returned by `plainFunction`</span>
  <span class="hljs-comment">// with co, since it "yields" a promise.</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> plainFunction();
  <span class="hljs-comment">// res.text now contains Google's home page HTML!</span>
});
</code></pre>
<p>The general idea of regenerator is simple: convert a generator function into
a regular function that returns an object that fulfills the ES2015 generator
API. Of course, the fake generator needs to return the correct values for
<code>next()</code>: every <code>yield</code> statement needs to cause a <code>next()</code> function call
to return. The above example is not sophisticated, it only allows you to
return a single value. You&#39;ll learn about how you can replace yield statements
with ES5 code in the &quot;Faking a Generator Function&quot; section.</p>
<p><br><br><br><br><br><br></p>
<p>Below is an example of using regenerator output with co. Note that,
even though it isn&#39;t defined using <code>function*</code>, co still accepts the
<code>generatorFunction</code> as a valid generator function. Like the fake version
of co you saw in the &quot;Asynchronous Coroutines&quot; chapter, co defines a generator
function as any object whose <code>constructor.name</code> property is equal to
&#39;Generator Function&#39;. Regenerator is smart enough to change this property for
you.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> regenerator = <span class="hljs-built_in">require</span>(<span class="hljs-string">'regenerator'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
<span class="hljs-comment">// Necessary to include the `regeneratorRuntime` variable</span>
<span class="hljs-comment">// that you use in the below generated code.</span>
regenerator.runtime();

<span class="hljs-comment">// The below code is regenerator's output when it transpiles</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// const generatorFunction = function*() {</span>
<span class="hljs-comment">//   return superagent.get('http://www.google.com');</span>
<span class="hljs-comment">// };</span>
<span class="hljs-keyword">var</span> generatorFunction = regeneratorRuntime.mark(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callee$0$0</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callee$0$0$</span>(<span class="hljs-params">context$1$0</span>) </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">switch</span> (context$<span class="hljs-number">1</span>$<span class="hljs-number">0.</span>prev = context$<span class="hljs-number">1</span>$<span class="hljs-number">0.</span>next) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> context$<span class="hljs-number">1</span>$<span class="hljs-number">0.</span>abrupt(<span class="hljs-string">"return"</span>,
          superagent.get(<span class="hljs-string">'http://www.google.com'</span>));
      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:
        <span class="hljs-keyword">return</span> context$<span class="hljs-number">1</span>$<span class="hljs-number">0.</span>stop();
    }
  }, callee$<span class="hljs-number">0</span>$<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);
});

<span class="hljs-comment">// 'GeneratorFunction'</span>
generatorFunction.constructor.name;

co(generatorFunction).then((res) =&gt; {
  <span class="hljs-comment">// res.text contains google's home page!</span>
});
</code></pre>
<h2 id="faking-a-generator-function">Faking a Generator Function</h2>
<p>The first key idea for writing generator functions in ES5 is that a generator
can be thought of as a series of functions calls that return values. The
difference between <code>yield</code> and <code>return</code> is that you can&#39;t resume a function after
<code>return</code> has been called. Thus, in order to build a generator function out of
normal functions, you need multiple function calls.</p>
<p>Regenerator handles this by creating a function that gets a parameter which
defines which &quot;step&quot; the generator is on. A step ends with a <code>return</code> statement, or a <code>yield</code> statement, which is transformed into a <code>return</code>. You can think
of a generator as being on the x-th step if there have been x yield statements
thus far.</p>
<p><br></p>
<p>Let&#39;s take a look at an example. Suppose you have the below generator function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
};
</code></pre>
<p>The above generator function has 2 steps:</p>
<ol>
<li><code>superagent.get(&#39;http://www.google.com&#39;)</code></li>
<li><code>return</code> the <code>text</code> property from the value that <code>generator.next()</code> gives you.</li>
</ol>
<p>In the below function, the <code>generatorLogic()</code> function executes these two steps.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

<span class="hljs-comment">// Behaves like the below generator function:</span>
<span class="hljs-comment">// const generatorFunction = function*() {</span>
<span class="hljs-comment">//   return (yield superagent.get('http://www.google.com')).text;</span>
<span class="hljs-comment">// };</span>
<span class="hljs-keyword">const</span> fakeGeneratorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> step = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> numSteps = <span class="hljs-number">2</span>;
  <span class="hljs-comment">// This function takes the value that was passed to `next()` and</span>
  <span class="hljs-comment">// the 'step' that the generator is on.</span>
  <span class="hljs-keyword">const</span> generatorLogic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, step</span>) </span>{
    <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
    <span class="hljs-keyword">if</span> (step === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> v.text;
  }

  <span class="hljs-keyword">return</span> {
    next: (v) =&gt; {
      <span class="hljs-comment">// For the first n-1 functions, return `done: false`</span>
      <span class="hljs-keyword">if</span> (step &lt; numSteps - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> {
          done: <span class="hljs-literal">false</span>,
          value: generatorLogic(v, step++)
        };
      }
      <span class="hljs-comment">// For last function, return `done: true`</span>
      <span class="hljs-comment">// (like a `return` in a generator)</span>
      <span class="hljs-keyword">return</span> {
        done: <span class="hljs-literal">true</span>,
        value: generatorLogic(v, step++)
      };
    },
    <span class="hljs-keyword">throw</span>: (error) =&gt; {
      <span class="hljs-keyword">throw</span> error;
    }
  }
};
</code></pre>
<p><br><br><br></p>
<p>There are two key points the previous example glossed over. The first point
is what happens with variable assignments? Suppose you had a generator function
that assigned to a variable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-keyword">return</span> res.text;
};
</code></pre>
<p>The <code>generatorLogic()</code> function needs to get called multiple times, and after
each <code>return</code> the function stack gets wiped out. There&#39;s no way to persist
local variables between calls to <code>generatorLogic()</code>. Right about now you&#39;re
probably starting to miss generators. The workaround is to store variables in
an object outside of the <code>generatorLogic()</code> function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> variables = {};

<span class="hljs-keyword">const</span> fakeGeneratorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, step</span>) </span>{
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">1</span>) {
    variables[<span class="hljs-string">'res'</span>] = v;
    <span class="hljs-keyword">return</span> variables[<span class="hljs-string">'res'</span>].text;
  }
};
</code></pre>
<p>The second and more tricky point is how to handle errors and try/catch. Remember
that generators have a <code>throw()</code> method that lets you trigger an error in the
generator function that you can try/catch. For instance:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> res;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// You'll get an error here (so the `catch` block will execute)</span>
    <span class="hljs-comment">// because co will call `throw()` when this `superagent.get()`</span>
    <span class="hljs-comment">// call fails.</span>
    res = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://notvalid.baddomain'</span>);
  } <span class="hljs-keyword">catch</span>(err) {
    <span class="hljs-comment">// When the error is thrown, this will return</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Failed'</span>;
  }
  <span class="hljs-keyword">return</span> res.text;
};
</code></pre>
<p>The general idea is that your <code>generatorLogic()</code> function needs to take an
<code>error</code> parameter, and you need to have a separate case for if you&#39;re on
step 1 and <code>generator.throw()</code> was called. In other words, the catch block
above needs to be in a separate <code>if()</code> statement.</p>
<p><br><br><br><br><br><br></p>
<p>Below is an example of how you can handle errors in your fake generator
function.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Behaves like the below generator function:</span>
<span class="hljs-comment">// const generatorFunction = function*() {</span>
<span class="hljs-comment">//   let res;</span>
<span class="hljs-comment">//   try {</span>
<span class="hljs-comment">//     res = yield superagent.get('http://notvalid.baddomain');</span>
<span class="hljs-comment">//   } catch(err) {</span>
<span class="hljs-comment">//     return 'Failed';</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">//   return res.text;</span>
<span class="hljs-comment">// };</span>
<span class="hljs-keyword">const</span> fakeGeneratorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> step = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> variables = {};
  <span class="hljs-keyword">const</span> result = (value, done) =&gt; {
    <span class="hljs-keyword">return</span> {
      value: value,
      done: done
    };
  };
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">'http://nota.baddomain'</span>;

  <span class="hljs-keyword">const</span> generatorLogic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, step, error</span>) </span>{
    <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result(superagent.get(url), <span class="hljs-literal">false</span>);
    <span class="hljs-comment">// This is the catch block</span>
    <span class="hljs-keyword">if</span> (step === <span class="hljs-number">1</span> &amp;&amp; error) <span class="hljs-keyword">return</span> result(<span class="hljs-string">'Failed'</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (step === <span class="hljs-number">1</span>) {
      variables[<span class="hljs-string">'res'</span>] = v;
      <span class="hljs-keyword">return</span> result(variables[<span class="hljs-string">'res'</span>].text, <span class="hljs-literal">true</span>);
    }
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error;
  }

  <span class="hljs-keyword">return</span> {
    next: (v) =&gt; generatorLogic(v, step++),
    <span class="hljs-comment">// `throw()` needs to set the error parameter to `next()`</span>
    <span class="hljs-keyword">throw</span>: (error) =&gt; generatorLogic(<span class="hljs-literal">null</span>, step++, error)
  }
};
</code></pre>
<p>In this section, your transpiler will <strong>not</strong> account for try/catch blocks
and variable assignments. Implementing these details would make the transpiler
too complex to serve as an digestible example. However, the previous examples
sketch the general idea of how you would implement variable assignments and
try/catch blocks.</p>
<p>There&#39;s one more detail to account for: defining an API for the generator
runtime that your transpiled generator functions will use. Your transpiler
will convert generator function code like what you see below:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
};
</code></pre>
<p><br></p>
<p>The converted ES5 code will look like what you see below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = GeneratorFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, step</span>) </span>{
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> generatorResult(
    superagent.get(<span class="hljs-string">'http://www.google.com'</span>), <span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> generatorResult(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>);
});
</code></pre>
<p>The above code uses 2 functions, <code>GeneratorFunction()</code> and <code>generatorResult()</code>.
These functions are the API for your generator runtime. Don&#39;t worry, they&#39;re
only cosmetically different from the logic in <code>fakeGeneratorFunction()</code> in
previous examples.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// We'll use 2 functions to convert a regular function into a</span>
<span class="hljs-comment">// generator. `generatorResult()` returns an object with the same</span>
<span class="hljs-comment">// format that `generator.next()` does.</span>
<span class="hljs-keyword">const</span> generatorResult = (value, done) =&gt; {
  <span class="hljs-keyword">return</span> {
    value: value,
    done: done
  };
};

<span class="hljs-comment">// `GeneratorFunction()` converts a fake generator function that</span>
<span class="hljs-comment">// takes the `v` and `step` parameters into something you can pass</span>
<span class="hljs-comment">// to `co()`</span>
<span class="hljs-keyword">const</span> GeneratorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fakeGeneratorFunction</span>) </span>{
  <span class="hljs-keyword">let</span> res = () =&gt; {
    <span class="hljs-keyword">let</span> step = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">return</span> {
      next: (v) =&gt; fakeGeneratorFunction(v, step++),
      <span class="hljs-keyword">throw</span>: (error) =&gt; {
        <span class="hljs-keyword">throw</span> error;
      }
    }
  };
  <span class="hljs-comment">// Make the result look like a generator function</span>
  <span class="hljs-built_in">Object</span>.defineProperty(res.constructor, <span class="hljs-string">'name'</span>, {
    value: <span class="hljs-string">'GeneratorFunction'</span>
  });

  <span class="hljs-comment">// Note that this example returns an actual faked generator</span>
  <span class="hljs-comment">// function rather than a fake generator like previous examples.</span>
  <span class="hljs-keyword">return</span> res;
};

<span class="hljs-comment">// Here's an example of passing a basic fake generator function</span>
<span class="hljs-comment">// to `GeneratorFunction()`</span>
co(GeneratorFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, step</span>) </span>{
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> generatorResult(
    superagent.get(<span class="hljs-string">'http://www.google.com'</span>), <span class="hljs-literal">false</span>);
  <span class="hljs-keyword">return</span> generatorResult(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>);
}))
</code></pre>
<h2 id="parsing-generators-with-esprima">Parsing Generators With Esprima</h2>
<p>In order to write a transpiler, you first need to learn to use a JavaScript
parser. Esprima is one of the most well-adopted JavaScript parsers. In this
section, you&#39;ll inspect the syntax trees esprima produces for generator
functions in preparation for writing your own rudimentary transpiler.</p>
<p>Esprima exposes a <code>parse()</code> function that takes in some JavaScript code and
outputs a <strong>syntax tree</strong>. A syntax tree is a tree that represents the
structure of the code - a syntax tree makes it much easier to transform
code than if you just tried to manipulate a string.</p>
<p>Below is an example syntax tree for a simple generator function. In particular,
note that the generator function expression is parsed onto a node that has
a <code>type</code> property equal to &quot;FunctionExpression&quot; and a <code>generator</code> property
that&#39;s set to true. It also has a <code>body</code> property that contains a <code>body</code> array
property which contains a <code>return</code> statement.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> esprima = <span class="hljs-built_in">require</span>(<span class="hljs-string">'esprima'</span>);

<span class="hljs-keyword">const</span> parsed = esprima.parse(<span class="hljs-string">`
  const generatorFunction = function*() {
    return 'Hello, World';
  };`</span>).body;

<span class="hljs-comment">/* `parsed` is an array that looks like what you see below
[
  {
    "type": "VariableDeclaration",
    "declarations": [
      {
        "type": "VariableDeclarator",
        "id": { "type": "Identifier", "name": "generatorFunction" },
        "init": {
          "type": "FunctionExpression",
          "params": [],
          "body": {
            "type": "BlockStatement",
            "body": [
              {
                "type": "ReturnStatement",
                "argument": {
                  "type": "Literal",
                  "value": "Hello, World",
                  "raw": "'Hello, World'"
                }
              }
            ]
          },
          "generator": true
        }
      }
    ],
    "kind": "const"
  }
] */</span>
</code></pre>
<p><br></p>
<p>Syntax trees can be confusing at first, but the key idea in this example is
what generator functions look like in the syntax tree.</p>
<p>Let&#39;s take a look at a simple problem: count the number of generator functions
in a piece of code. You&#39;d need to visit each node in the
tree and check if it has a <code>type</code> property equal to &#39;FunctionExpression&#39; and
a <code>generator</code> property equal to &#39;true&#39;. The hard part is how to visit each
node in the tree. To make that easier, you&#39;ll use the estraverse module. This
module lets you execute two functions for each node in the tree, an <code>enter()</code>
function that executes before the traversal visits any child nodes, and
a <code>leave()</code> function that executes after the traversal visits all child nodes.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> esprima = <span class="hljs-built_in">require</span>(<span class="hljs-string">'esprima'</span>);
<span class="hljs-keyword">const</span> estraverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">'estraverse'</span>);

<span class="hljs-keyword">const</span> parsed = esprima.parse(<span class="hljs-string">`
  const generatorFunction = function*() {
    yield function*() {
      yield 'Hello, World!';
    };
  };`</span>);

<span class="hljs-keyword">let</span> numGenerators = <span class="hljs-number">0</span>;
estraverse.traverse(parsed, {
  enter: (node, parent) =&gt; {
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'FunctionExpression'</span> &amp;&amp; node.generator) {
      ++numGenerators;
    }
  },
  leave: () =&gt; {}
});
assert.equal(numGenerators, <span class="hljs-number">2</span>);
</code></pre>
<p>Let&#39;s take a look at a more challenging problem that will be more useful for
your rudimentary transpiler: count the number of <code>yield</code> statements in each
generator function. For instance, in the previous example, you had 2 generator
functions, each with 1 yield statement.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>;
  };
};
</code></pre>
<p>For this example, the correct output would be <code>[1, 1]</code>, because both the first
and the second generator functions have 1 yield statement. What about a
trickier case?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>;
  };
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>;
};
</code></pre>
<p><br></p>
<p>The correct output is <code>[2, 1]</code> because the first generator function has 2
yield statements. However, estraverse will visit the 2nd yield statement
after the 2nd generator function.</p>
<p>To properly handle the case where you <code>yield</code> a generator and then <code>yield</code>
another value, you&#39;re going to use a stack and the estraverse <code>leave()</code>
function as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> parsed = esprima.parse(<span class="hljs-string">`
  const generatorFunction = function*() {
    yield function*() {
      yield 'Hello, World!';
    };
    yield 'Hello, World!';
  };`</span>);

<span class="hljs-keyword">let</span> res = [];
<span class="hljs-keyword">let</span> stack = [];
estraverse.traverse(parsed, {
  enter: (node, parent) =&gt; {
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'FunctionExpression'</span> &amp;&amp; node.generator) {
      <span class="hljs-comment">// We've found a new generator function, so add a 0 to the</span>
      <span class="hljs-comment">// result array and push the index of this generator function's</span>
      <span class="hljs-comment">// count in the result array onto the stack</span>
      stack.push(res.length);
      res.push(<span class="hljs-number">0</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'YieldExpression'</span>) {
      <span class="hljs-comment">// We've found a yield statement! Increment the current</span>
      <span class="hljs-comment">// generator function's count.</span>
      ++res[stack[stack.length - <span class="hljs-number">1</span>]];
    }
  },
  leave: (node, parent) =&gt; {
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'FunctionExpression'</span> &amp;&amp; node.generator) {
      <span class="hljs-comment">// We've visited everything within a generator function, so</span>
      <span class="hljs-comment">// pop its index off the stack</span>
      stack.pop();
    }
  }
});
assert.deepEqual(res, [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);
</code></pre>
<h2 id="write-your-own-transpiler">Write Your Own Transpiler</h2>
<p>Now that you&#39;ve seen how the syntax tree for generator functions looks, it&#39;s
time to implement a rudimentary transpiler for generator functions using
your runtime API from the &quot;Faking a Generator Function&quot; section. Your
transpiler will be far from a fully fledged regenerator replacement, but it
will be able to transpile some basic generator functions.</p>
<p>The transpiler needs to perform 3 distinct tasks:</p>
<ul>
<li>Convert generator functions into calls to <code>GeneratorFunction()</code>.</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-comment">// Before</span>
<span class="hljs-keyword">const</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{};
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-comment">// After</span>
<span class="hljs-keyword">const</span> f = GeneratorFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, step</span>)) </span>{}
</code></pre>
<ul>
<li>Convert <code>yield</code> and <code>return</code> expressions to returns that use
<code>generatorResult()</code>.</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-comment">// Before</span>
<span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello'</span>;
<span class="hljs-keyword">return</span> <span class="hljs-string">'World'</span>;
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-comment">// After</span>
<span class="hljs-keyword">return</span> generatorResult(<span class="hljs-string">'Hello'</span>, <span class="hljs-literal">false</span>);
<span class="hljs-keyword">return</span> generatorResult(<span class="hljs-string">'World'</span>, <span class="hljs-literal">true</span>);
</code></pre>
<ul>
<li>Break the function body up into steps based on <code>yield</code> and <code>return</code>
statements.</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-comment">// Before</span>
<span class="hljs-keyword">const</span> variables = {};
<span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  variables[<span class="hljs-string">'res'</span>] = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-keyword">return</span> variables[<span class="hljs-string">'res'</span>].text;
};
</code></pre>
<pre><code class="lang-javascript"><span class="hljs-comment">// After</span>
<span class="hljs-keyword">const</span> generatorFunction = GeneratorFunction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, step</span>) </span>{
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> generatorResult(
      superagent.get(<span class="hljs-string">'http://www.google.com'</span>), <span class="hljs-literal">false</span>);
  }
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// Note that we need to assign to the value passed to `next()`</span>
    variables[<span class="hljs-string">'res'</span>] = v;
    <span class="hljs-keyword">return</span> generatorResult(variables[<span class="hljs-string">'res'</span>], <span class="hljs-literal">true</span>);
  }
});
</code></pre>
<p><br></p>
<p>You&#39;re going to implement all these steps separately, because one block of
code that does all of these steps at once is too complex. The first step,
converting <code>function*</code> into a call to <code>GeneratorFunction()</code>, is the most
straightforward. You need to take each &#39;FunctionExpression&#39; node that has a
<code>generator</code> flag set and convert it into a non-generator within a
&#39;CallExpression&#39; node as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> esprima = <span class="hljs-built_in">require</span>(<span class="hljs-string">'esprima'</span>);
<span class="hljs-keyword">const</span> estraverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">'estraverse'</span>);
<span class="hljs-comment">// escodegen exposes a `generate()` function that takes</span>
<span class="hljs-comment">// an esprima syntax tree and outputs code as a string.</span>
<span class="hljs-keyword">const</span> escodegen = <span class="hljs-built_in">require</span>(<span class="hljs-string">'escodegen'</span>);

<span class="hljs-keyword">const</span> parsed = esprima.parse(<span class="hljs-string">`
  const variables = [];
  const generatorFunction = function*() {
    variables['res'] = yield superagent.get('http://www.google.com');
    return variables['res'];
  };`</span>);

estraverse.replace(parsed, {
  enter: (node, parent) =&gt; {
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'FunctionExpression'</span> &amp;&amp; node.generator) {
      node.generator = <span class="hljs-literal">false</span>;
      node.params.push({
        type: <span class="hljs-string">'Identifier'</span>,
        name: <span class="hljs-string">'v'</span>
      });
      node.params.push({
        type: <span class="hljs-string">'Identifier'</span>,
        name: <span class="hljs-string">'step'</span>
      });
      <span class="hljs-comment">// This property will identify this node as a former</span>
      <span class="hljs-comment">// generator function</span>
      node._steps = [[]];

      <span class="hljs-keyword">return</span> {
        type: <span class="hljs-string">'CallExpression'</span>,
        callee: {
          type: <span class="hljs-string">'Identifier'</span>,
          name: <span class="hljs-string">'GeneratorFunction'</span>
        },
        <span class="hljs-built_in">arguments</span>: [node]
      }
    }
  }
});

assert.equal(escodegen.generate(parsed), <span class="hljs-string">`
const variables = [];
const generatorFunction = GeneratorFunction(function (v, step) {
    variables['res'] = yield superagent.get('http://www.google.com');
    return variables['res'];
});`</span>.trim());
</code></pre>
<p><br><br></p>
<p>The second step for the transpiler is to convert <code>yield</code> and <code>return</code> statements
to <code>return</code> statements that use the <code>generatorResult()</code> function. This ensures
the resulting generator&#39;s <code>next()</code> returns properly formated results. To do
this, every &#39;YieldExpression&#39; and &#39;ReturnStatement&#39; node needs to be
transformed to a &#39;ReturnStatement&#39; that returns a call to <code>generatorResult()</code>,
as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> parsed = esprima.parse(<span class="hljs-string">`
  const variables = [];
  const generatorFunction = function*() {
    variables['res'] = yield superagent.get('http://www.google.com');
    return variables['res'];
  };`</span>);
<span class="hljs-keyword">const</span> FunctionCall = (name, args) =&gt; {
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-string">'CallExpression'</span>,
    callee: {
      type: <span class="hljs-string">'Identifier'</span>,
      name: name
    },
    <span class="hljs-built_in">arguments</span>: args
  };
};
<span class="hljs-keyword">const</span> Literal = (value) =&gt; {
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-string">'Literal'</span>,
    value: value,
    raw: value.toString()
  };
};

estraverse.replace(parsed, {
  enter: (node, parent) =&gt; {},
  leave: (node, parent) =&gt; {
    <span class="hljs-keyword">const</span> type = node.type;
    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'YieldExpression'</span> || type === <span class="hljs-string">'ReturnStatement'</span>) {
      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'ReturnStatement'</span>) {
        <span class="hljs-keyword">const</span> args = [node.argument, Literal(<span class="hljs-literal">true</span>)];
        node.argument = FunctionCall(<span class="hljs-string">'generatorResult'</span>, args);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'YieldExpression'</span>) {
        node.type = <span class="hljs-string">'ReturnStatement'</span>;
        node._wasYield = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">const</span> args = [node.argument, Literal(<span class="hljs-literal">false</span>)];
        node.argument = FunctionCall(<span class="hljs-string">'generatorResult'</span>, args);
      }
    }
  }
});

<span class="hljs-keyword">const</span> yieldStatement = <span class="hljs-string">`superagent.get('http://www.google.com')`</span>;
assert.equal(escodegen.generate(parsed), <span class="hljs-string">`
const variables = [];
const generatorFunction = GeneratorFunction(function (v, step) {
    variables['res'] = return generatorResult(<span class="hljs-subst">${yieldStatement}</span>, false);;
    return generatorResult(variables['res'], true);
});`</span>.trim());
</code></pre>
<p><br></p>
<p>The third and final step is the most complex. This step has 2 primary
objectives. First, you need to break up the code into steps: all the code
between <code>return</code> statements needs to be wrapped in an <code>if</code> statement that
checks the current <code>step</code>. To do this, you&#39;ll add a 2d array <code>_steps</code> to every
generator function node. You&#39;ll add each top-level expression to the last
element of the <code>_steps</code> array, and add a new empty array to the <code>_steps</code> array
every time you see a return statement.</p>
<p>Secondly, you need to transform any assignments that have a <code>yield</code> statement
as the right-hand side. To do this, you&#39;ll add a new &#39;AssignmentExpression&#39; to
the start of the next step that assigns to the parameter <code>v</code>, which is the
value passed to <code>generator.next()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> clone = v =&gt; <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(v));
<span class="hljs-keyword">const</span> Identifier = name =&gt; ({ type: <span class="hljs-string">'Identifier'</span>, name: name });
<span class="hljs-keyword">const</span> BlockStatement = body =&gt; ({ type: <span class="hljs-string">'BlockStatement'</span>, body: body });
<span class="hljs-keyword">const</span> ReturnStatement = v =&gt; ({ type: <span class="hljs-string">'ReturnStatement'</span>, argument: v });
<span class="hljs-keyword">const</span> If = (t, c) =&gt; ({ type: <span class="hljs-string">'IfStatement'</span>, test: t, consequent: c });
<span class="hljs-keyword">const</span> Test = (l, r) =&gt; ({ type: <span class="hljs-string">'BinaryExpression'</span>, operator: <span class="hljs-string">'==='</span>,
  left: l, right: r });
<span class="hljs-keyword">let</span> stack = [];
<span class="hljs-keyword">let</span> lastGen = () =&gt; stack.length &amp;&amp; stack[stack.length - <span class="hljs-number">1</span>];
estraverse.replace(parsed, {
  enter: (node, parent) =&gt; {
    <span class="hljs-comment">// Keep track of nested generator functions</span>
    <span class="hljs-keyword">if</span> (node._steps) stack.push(node);
    <span class="hljs-comment">// Put top-level expressions into the `_steps` array</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastGen() &amp;&amp; lastGen().body === parent)
      lastGen()._steps[lastGen()._steps.length - <span class="hljs-number">1</span>].push(node);
  },
  leave: (node, parent) =&gt; {
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'ExpressionStatement'</span> &amp;&amp;
        node.expression.type === <span class="hljs-string">'AssignmentExpression'</span> &amp;&amp;
        node.expression.right._wasYield) {
      <span class="hljs-comment">// Handle assigning to result of `yield`</span>
      <span class="hljs-keyword">const</span> newNode = clone(node);
      newNode.expression.right = Identifier(<span class="hljs-string">'v'</span>);
      lastGen()._steps[lastGen()._steps.length - <span class="hljs-number">1</span>].push(newNode);
      node.type = <span class="hljs-string">'ReturnStatement'</span>;
      node.argument = node.expression.right.argument;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'FunctionExpression'</span> &amp;&amp; node._steps) {
      <span class="hljs-comment">// Merge all of the steps into if statements</span>
      <span class="hljs-keyword">const</span> newBody = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; node._steps.length - <span class="hljs-number">1</span>; ++i) {
        <span class="hljs-comment">// Wrap each step in an if statement</span>
        <span class="hljs-keyword">const</span> test = Test(Identifier(<span class="hljs-string">'step'</span>), Literal(i));
        newBody.push(If(test, BlockStatement(clone(node._steps[i]))));
      }
      <span class="hljs-keyword">const</span> r = [Identifier(<span class="hljs-literal">undefined</span>), Literal(<span class="hljs-literal">true</span>)];
      newBody.push(ReturnStatement(FunctionCall(<span class="hljs-string">'generatorResult'</span>, r)));
      node.body.body = newBody;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-string">'ReturnStatement'</span>) {
      <span class="hljs-comment">// If there's a return, create a new step</span>
      lastGen()._steps.push([]);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node._steps) stack.pop();
  }
});
</code></pre>
<p><br></p>
<p>And that&#39;s it! Now you have a fully transpiled fake generator function. If you
pass <code>generatorFunction()</code> into co, it will work as expected.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> variables = [];
<span class="hljs-keyword">const</span> generatorFunction = GeneratorFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v, step</span>) </span>{
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> generatorResult(superagent.get(<span class="hljs-string">'http://www.google.com'</span>),
      <span class="hljs-literal">false</span>);
  }
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">1</span>) {
    variables[<span class="hljs-string">'res'</span>] = v;
    <span class="hljs-keyword">return</span> generatorResult(variables[<span class="hljs-string">'res'</span>], <span class="hljs-literal">true</span>);
  }
  <span class="hljs-keyword">return</span> generatorResult(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>);
});
</code></pre>
<p>This transpiler has numerous limitations: it doesn&#39;t support try/catch blocks,
variable declarations, if statements, or for loops. That&#39;s why you should
use regenerator instead of writing your own: writing a fully-fledged transpiler
for generators is very hard! However, in writing your own
transpiler, you got to actually apply the ES2015 spec&#39;s definition of generators
and see how they work in terms of plain-old functions.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Generator Runtime API</span>
<span class="hljs-keyword">const</span> generatorResult = (v, done) =&gt; ({ value: v, done: done });
<span class="hljs-keyword">const</span> GeneratorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">let</span> res = () =&gt; {
    <span class="hljs-keyword">let</span> step = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> { next: (v) =&gt; fn(v, step++), <span class="hljs-keyword">throw</span>: (e) =&gt; { <span class="hljs-keyword">throw</span> e; } };
  };
  <span class="hljs-built_in">Object</span>.defineProperty(res.constructor, <span class="hljs-string">'name'</span>,
    { value: <span class="hljs-string">'GeneratorFunction'</span> });
  <span class="hljs-keyword">return</span> res;
};

<span class="hljs-keyword">const</span> variables = [];
co(GeneratorFunction(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v, step</span>) </span>{
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> generatorResult(superagent.get(<span class="hljs-string">'http://www.google.com'</span>),
      <span class="hljs-literal">false</span>);
  }
  <span class="hljs-keyword">if</span> (step === <span class="hljs-number">1</span>) {
    variables[<span class="hljs-string">'res'</span>] = v;
    <span class="hljs-keyword">return</span> generatorResult(variables[<span class="hljs-string">'res'</span>], <span class="hljs-literal">true</span>);
  }
  <span class="hljs-keyword">return</span> generatorResult(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>);
})).then((v) =&gt; {
  <span class="hljs-comment">// v contains google home page HTML</span>
});
</code></pre>

      <h1 id="chapter-5-moving-on">Chapter 5: Moving On</h1>
<p>Congratulations! If you&#39;ve gotten this far, you&#39;ve seen the fundamentals of
generators and how to implement your own take on co, koa, and regenerator.
Generators are a powerful tool, they enable you to implement scheduling for
CPU-intensive calculations, callback-free asynchronous code, and highly
composable web server applications.</p>
<p>You may have heard of ES2016 and the async/await keywords. The upcoming ES2016
spec will include out-of-the-box support for the callback-free asynchronous
code that <code>co()</code> enables.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">googleHomepage</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
}
<span class="hljs-built_in">console</span>.log((<span class="hljs-keyword">await</span> googleHomepage()).text);
</code></pre>
<p>However, ES2016 is not yet finalized. As people who were excited about ES2016&#39;s
proposed <code>Object.observe()</code> feature learned the hard way, major features are
often changed significantly or even cut entirely before the spec is finalized.
Don&#39;t pull all your eggs in the async/await basket until the ES2016 spec is
formally approved! Even when the spec is approved, most browsers will not
support async/await, so you will need a transpiler. Not surprisingly, modern
async/await transpilers use generators and asynchronous coroutines under the
hood.</p>
<p>Congratulations again on completing this guide, and good luck with your
ES2015 coding adventures!</p>

    </div>
    <script type="text/javascript">
      var start = 3400;
      var delta = 1681;
      for (var i = 2; i < 52; ++i) {
        var height = start + (i - 1) * delta;
        document.write('<div class="page-num" style="top:' + height + 'px;">' + (i - 1) + '</div>');
      }
    </script>
  