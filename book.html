
    <link href='http://fonts.googleapis.com/css?family=Titillium+Web' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
    <style>
      html {
  font-family: 'Roboto';
  font-size: 24px;
}

h1 {
  padding-top: 100px;
  page-break-before: always;
}

h2 {
  padding-top: 75px;
}

.page-break {
  page-break-before: always;
}

h1,h2,h3,h4,p,ul,ol,pre {
  margin-left: 50px;
  margin-right: 50px;
}

pre {
  border: 1px solid #dfdfdf;
  padding: 15px;
}

code {
  font-family: 'Droid Sans Mono';
}

p {
  line-height: 1.5em;
}

p code {
  color: #232323;
}

li {
  margin-left: 50px;
}

a {
  color: black;
  float: right;
  text-decoration: none;
  font-weight: bold;
}

.page-num {
  position: absolute;
  right: 50px;
  font-size: 0.75em;
  font-color: #333333;
}

.cover img {
  position: relative;
  left: -250px;
  top: -8px;
  height: 1300px;
  margin: 0px;
  padding: 0px;
}

.cover .info {
  position: absolute;
  top: 1240px;
  left: -8px;
  background-color: black;
  color: white;
  height: 441px;
  width: 1500px;
}

.title {
  padding-left: 50px;
  font-family: 'Titillium Web';
  font-size: 48pt;
  font-weight: bold;
}

.author {
  padding-left: 50px;
  font-family: 'Titillium Web';
  font-size: 36pt;
  margin-top: 15px;
}

.top-triangle {
  position: absolute;
  top: 1100px;
  left: 0px;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 200px 0 0 2000px;
  border-color: transparent transparent transparent black;
}

/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-javadoc {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.css .rule .hljs-keyword,
.hljs-winutils,
.nginx .hljs-title,
.hljs-subst,
.hljs-request,
.hljs-status {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-hexcolor,
.ruby .hljs-constant {
  color: #008080;
}

.hljs-string,
.hljs-tag .hljs-value,
.hljs-phpdoc,
.hljs-dartdoc,
.tex .hljs-formula {
  color: #d14;
}

.hljs-title,
.hljs-id,
.scss .hljs-preprocessor {
  color: #900;
  font-weight: bold;
}

.hljs-list .hljs-keyword,
.hljs-subst {
  font-weight: normal;
}

.hljs-class .hljs-title,
.hljs-type,
.vhdl .hljs-literal,
.tex .hljs-command {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-tag .hljs-title,
.hljs-rules .hljs-property,
.django .hljs-tag .hljs-keyword {
  color: #000080;
  font-weight: normal;
}

.hljs-attribute,
.hljs-variable,
.lisp .hljs-body {
  color: #008080;
}

.hljs-regexp {
  color: #009926;
}

.hljs-symbol,
.ruby .hljs-symbol .hljs-string,
.lisp .hljs-keyword,
.clojure .hljs-keyword,
.scheme .hljs-keyword,
.tex .hljs-special,
.hljs-prompt {
  color: #990073;
}

.hljs-built_in {
  color: #0086b3;
}

.hljs-preprocessor,
.hljs-pragma,
.hljs-pi,
.hljs-doctype,
.hljs-shebang,
.hljs-cdata {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.diff .hljs-change {
  background: #0086b3;
}

.hljs-chunk {
  color: #aaa;
}

    </style>
    <div id="content">
      <div class="cover">
  <img src="http://i.imgur.com/nG4gisP.jpg" />
  <div class="top-triangle"></div>
  <div class="info">
    <div class="title">
      The 80/20 Guide to ES2015 Generators
    </div>
    <div class="author">
      Valeri Karpov
    </div>
  </div>
</div>

      <h1 id="table-of-contents">Table of Contents</h1>
<h3 id="1-getting-started-with-generators-1-1-">1. Getting Started With Generators <a href="#1">1</a></h3>
<ol>
<li>What is a Generator? <a href="#1">1</a></li>
<li>Case Study: Async Fibonacci <a href="#3">3</a></li>
<li>For/Of Loops <a href="#5">5</a></li>
<li>Error Handling <a href="#7">7</a></li>
<li>Case Study: Handling Async Errors <a href="#8">8</a></li>
</ol>
<h3 id="2-asynchronous-coroutines-10-10-">2. Asynchronous Coroutines <a href="#10">10</a></h3>
<ol>
<li>Promises and Thunks <a href="#10">10</a></li>
<li>Write Your Own Co <a href="#14">14</a></li>
<li>Limitations</li>
<li>The Real Implementation of Co</li>
<li>Case Study: HTTP Requests with Co</li>
</ol>
<h3 id="3-koa-and-middleware">3. Koa and Middleware</h3>
<ol>
<li>The Composition Module</li>
<li>Writing Your Own Generator-Based Middleware</li>
<li>Introducing Koa</li>
<li>Case Study: Koa Error Handling Middleware</li>
</ol>
<h3 id="4-transpiling">4. Transpiling</h3>
<ol>
<li>Introducing <code>regenerator</code></li>
<li>Parsing Generators With Esprima</li>
<li>Write Your Own Transpiler</li>
</ol>
<h3 id="5-moving-on">5. Moving On</h3>

      <h1 id="chapter-1-getting-started">Chapter 1: Getting Started</h1>
<p>Generators are a powerful new feature in ES2015. Generators are far from a
new programming construct - they first appeared in 1975 and Python has had
them since Python 2.2 in 2001. However, as you&#39;ll see, generators are
even more powerful in an event-driven language like JavaScript. In JavaScript
(assuming Node.js &gt;= 4.0.0), a <strong>generator function</strong> is defined as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
};
</code></pre>
<p>However, if you run <code>generatorFunction</code>, you&#39;ll notice that the return value
is an object.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>); };
<span class="hljs-literal">undefined</span>
&gt; generatorFunction()
{}
</code></pre><p>That&#39;s because a generator function creates and returns a <strong>generator object</strong>.
Typically, the term <strong>generator</strong> refers to a generator object rather than
a generator function. A generator object has a single function, <code>next()</code>.
If you execute the generator object&#39;s <code>next()</code> function, you&#39;ll notice
that Node.js printed &#39;Hello, World!&#39; to the screen.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>); };
<span class="hljs-literal">undefined</span>
&gt; generatorFunction()
{}
&gt; generatorFunction().next()
Hello, World!
{ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> }
&gt;
</code></pre><p>Notice that <code>next()</code> returned an object, <code>{ value: undefined, done: true }</code>.
The meaning of this object is tied to the <code>yield</code> keyword. To introduce you
to the <code>yield</code> keyword, consider the following generator function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>;
};
</code></pre>
<p><br><br><br><br><br>
<br></p>
<p>Let&#39;s see what happens when you call <code>next()</code> on the resulting generator.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>; };
<span class="hljs-literal">undefined</span>
&gt; <span class="hljs-keyword">var</span> generator = generatorFunction();
<span class="hljs-literal">undefined</span>
&gt; generator.next();
{ value: <span class="hljs-string">'Hello, World!'</span>, done: <span class="hljs-literal">false</span> }
&gt; generator.next();
{ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> }
&gt;
</code></pre><p>Notice that, the first time you call <code>generator.next()</code>, the <code>value</code> property
is equal to the string your generator function yielded. You can think of
<code>yield</code> as the generator-specific equivalent of the <code>return</code> statement.</p>
<p>You might be wondering why the return value of <code>generator.next()</code> has a <code>done</code>
property. The reason is tied to why <code>yield</code> is different from <code>return</code>.</p>
<h3 id="-yield-vs-return-"><code>yield</code> vs <code>return</code></h3>
<p>The <code>yield</code> keyword can be thought of as a <code>return</code> that allows <strong>re-entry</strong>.
In other words, once <code>return</code> executes, the currently executing function is
done forever. However, when you call <code>generator.next()</code>, the JavaScript
interpreter executes the generator function until the first <code>yield</code> statement.
When you call <code>generator.next()</code> again, the generator function picks up where
it left off. You can think of a generator as a function that can &quot;return&quot;
multiple values.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">'Hello'</span>;
  <span class="hljs-keyword">yield</span> message;
  message += <span class="hljs-string">', World!'</span>;
  <span class="hljs-keyword">yield</span> message;
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-comment">// { value: 'Hello', done: false };</span>
<span class="hljs-keyword">const</span> v1 = generator.next();
<span class="hljs-comment">// { value: 'Hello, World!', done: false }</span>
<span class="hljs-keyword">const</span> v2 = generator.next();
<span class="hljs-comment">// { value: undefined, done: true }</span>
<span class="hljs-keyword">const</span> v3 = generator.next();
</code></pre>
<h3 id="re-entry">Re-entry</h3>
<p>The most important detail from the above example is that, when <code>yield</code>
executes, the generator function stops executing until the next time you call
<code>generator.next()</code>. You can call <code>generator.next()</code> whenever you want, even in
a <code>setTimeout()</code>. The JavaScript interpreter will re-enter the generator
function with the same state that it left off with.</p>
<p><br>
<br></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>) {
    <span class="hljs-keyword">yield</span> i;
    ++i;
  }
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-keyword">let</span> x = generator.next(); <span class="hljs-comment">// { value: 0, done: false }</span>
setTimeout(() =&gt; {
  x = generator.next(); <span class="hljs-comment">// { value: 1, done: false }</span>
  x = generator.next(); <span class="hljs-comment">// { value: 2, done: false }</span>
  x = generator.next(); <span class="hljs-comment">// { value: undefined, done: true }</span>
}, <span class="hljs-number">50</span>);
</code></pre>
<h3 id="-yield-vs-return-revisited"><code>yield</code> vs <code>return</code> revisited</h3>
<p>You may be wondering what happens when you use <code>return</code>
instead of <code>yield</code> in a generator. As you might expect,
<code>return</code> behaves similarly to <code>yield</code>, except for
<code>done</code> is set to true.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, World!'</span>;
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-comment">// { value: 'Hello, World!', done: true }</span>
<span class="hljs-keyword">const</span> v = generator.next();
</code></pre>
<h2 id="case-study-async-fibonacci">Case Study: Async Fibonacci</h2>
<p>The fact that you can execute <code>generator.next()</code> asynchronously hints at
why generators are so useful. You can execute <code>generator.next()</code> synchronously
or asynchronously without changing the implementation of the generator
function.</p>
<p><div class="page-break"></div>
<br><br></p>
<p>For instance, lets say you wrote a generator
function that computes the Fibonacci Sequence. Note that generator functions
can take parameters like any function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacciGenerator = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">let</span> back2 = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> back1 = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) {
    cur = back2 + back1;
    back2 = back1;
    back1 = cur;
    <span class="hljs-keyword">yield</span> cur;
  }

  <span class="hljs-keyword">return</span> cur;
};
</code></pre>
<p>You could compute the n-th Fibonacci number synchronously using the code
below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-keyword">let</span> it;
<span class="hljs-keyword">for</span> (it = fibonacci.next(); !it.done; it = fibonacci.next()) {}
it.value; <span class="hljs-comment">// 55, the 10th fibonacci number</span>
</code></pre>
<p>However, computing the n-th Fibonacci number synchronously is not a hard
problem without generators. To make things interesting, let&#39;s say you wanted
to compute a very large Fibonacci number <strong>without blocking the event loop</strong>.
Normally, a JavaScript for loop would block the event loop. In other words,
no other JavaScript code can execute until the for loop in the previous
example is done. This can get problematic if you want to compute the 100
millionth Fibonacci number in an Express route handler. Without generators,
breaking up a long-running calculation can be cumbersome.</p>
<p>However, since you have a generator function that yields after each iteration
of the for loop, you can call <code>generator.next()</code> in a <code>setInterval()</code>
function. This will compute the next Fibonacci number with each iteration of
the event loop, and so won&#39;t prevent Node.js from responding from incoming
requests. You can make your Fibonacci calculation asynchronous without
changing the generator function!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-comment">// And compute one new Fibonacci number with each iteration</span>
<span class="hljs-comment">// through the event loop.</span>
<span class="hljs-keyword">const</span> interval = setInterval(() =&gt; {
  <span class="hljs-keyword">const</span> res = fibonacci.next();
  <span class="hljs-keyword">if</span> (res.done) {
    clearInterval(interval);
    res.value; <span class="hljs-comment">// 55, the 10th fibonacci number</span>
  }
}, <span class="hljs-number">0</span>);
</code></pre>
<h2 id="for-of-loops">For/Of Loops</h2>
<p>Remember the for loop you saw for exhausting the Fibonacci generator?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (it = fibonacci.next(); !it.done; it = fibonacci.next()) {}
</code></pre>
<p>This for loop is a perfectly reasonable way of going through every value of
the generator. However, ES2015 introduces a much cleaner mechanism for
looping through generators: the <code>for-of</code> loop.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  x; <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
</code></pre>
<h3 id="iterators-and-iterables">Iterators and Iterables</h3>
<p>For/Of loops aren&#39;t just for generators. A generator is actually an instance
of a more general ES2015 concept called an iterator. An <strong>iterator</strong> is
any JavaScript object that has a <code>next()</code> function that returns
<code>{ value: Any, done: Boolean }</code>. A generator is one example of an iterator.
You can also iterate over arrays:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) {
  x; <span class="hljs-comment">// 1, 2, 3</span>
}
</code></pre>
<p>However, For/Of loops don&#39;t operate on iterators, they operate on iterables.
An <strong>iterable</strong> is an object that has a <code>Symbol.iterator</code> property which is
a function that returns an iterator. In other words, when you execute a
For/Of loop, the JavaScript interpreter looks for a <code>Symbol.iterator</code> property
on the object you&#39;re looping <code>of</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> iterable = {};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {} <span class="hljs-comment">// Throws an error</span>

<span class="hljs-comment">// But once you add a Symbol.iterator property, everything works!</span>
iterable[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fibonacciGenerator(<span class="hljs-number">10</span>);
};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {
  x; <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
</code></pre>
<h3 id="a-brief-overview-of-symbols">A Brief Overview of Symbols</h3>
<p><strong>Symbols</strong> are another new feature in ES2015. Since this book is about
generators, we won&#39;t explore symbols in depth, just enough to understand
what the mysterious <code>iterable[Symbol.iterator]</code> code in the previous example
is about.</p>
<p><br><br><br></p>
<p>You can think of a symbol as a unique identifier for a key on an object.
For instance, suppose you wrote your own programming language and defined
an iterable as an object that had a property named <code>iterator</code>. Now, every
object that has a property named <code>iterator</code> would be an iterable, which
could lead to some unpredictable behavior. For instance, suppose you added
a property named <code>iterator</code> to an array - now you&#39;ve accidentally broken
for/of loops for that array!</p>
<p>Symbols protect you from the issue of accidental string collision. No string
key is equal to <code>Symbol.iterator</code>, so you don&#39;t have to worry about
accidentally breaking an iterable. Furthermore, symbols don&#39;t appear in
the output of <code>Object.keys()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">Symbol</span>.iterator; <span class="hljs-comment">// Symbol(Symbol.iterator)</span>

<span class="hljs-keyword">let</span> iterable = {};
iterable[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fibonacciGenerator(<span class="hljs-number">10</span>);
};

iterable.iterator; <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Object</span>.keys(iterable); <span class="hljs-comment">// Empty array!</span>
</code></pre>
<h3 id="iterables-and-generators">Iterables and Generators</h3>
<p>The most important detail to note about generators and iterables is that
<em>generator objects</em> are iterables, not <em>generator functions</em>. In order words,
you can&#39;t run a for/of loop on a generator function.</p>
<pre><code class="lang-javascript">fibonacciGenerator[<span class="hljs-built_in">Symbol</span>.iterable]; <span class="hljs-comment">// Undefined</span>
fibonacciGenerator(<span class="hljs-number">10</span>)[<span class="hljs-built_in">Symbol</span>.iterable]; <span class="hljs-comment">// Function</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacciGenerator) {} <span class="hljs-comment">// Error!</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacciGenerator(<span class="hljs-number">10</span>)) {} <span class="hljs-comment">// Ok</span>
</code></pre>
<p>You may find it strange that the generator&#39;s
<code>Symbol.iterator</code> function returns itself given that generator functions are
not iterable. One reason for this decision is that a generator function can
take parameters. For instance, looping over <code>fibonacciGenerator(10)</code> would not
give the same results as looping over <code>fibonacciGenerator(11)</code>.</p>
<p>The second most important detail to note about generators and iterables
is that <code>generator[Symbol.iterator]</code> is a function that returns the
generator itself. This means that you can&#39;t loop over the same generator
twice. Once a generator is done, subsequent for/of loops will exit immediately.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
fibonacci[<span class="hljs-built_in">Symbol</span>.iterator]() === fibonacci; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  <span class="hljs-comment">// Doesn't run!</span>
}
</code></pre>
<h2 id="error-handling">Error Handling</h2>
<p>One detail that has been glossed over so far is how generators handle
exceptions. What happens when you divide by zero in a generator? As you
might have guessed, the <code>generator.next()</code> call throws an error.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops!'</span>);
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-comment">// throws an error</span>
generator.next();
</code></pre>
<p>The error&#39;s stack trace reflects the fact that <code>next()</code> was the function
that called the function that threw the error. In particular, if you call
<code>next()</code> asynchronously, you will lose the original stack trace.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops!'</span>);
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

setTimeout(() =&gt; {
  <span class="hljs-keyword">try</span> {
    generator.next();
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">/**
     * Error: oops!
     * at generatorFunction (book.js:2:15)
     * at next (native)
     * at null._onTimeout (book.js:18:21)
     * at Timer.listOnTimeout (timers.js:89:15)
     */</span>
    err.stack;
  }
}, <span class="hljs-number">0</span>);
</code></pre>
<h3 id="re-entry-with-error">Re-entry With Error</h3>
<p>When you think of generators, you need to think of 2 functions: the generator
function itself, and the function that&#39;s calling <code>next()</code> on the generator.
When the generator function calls <code>yield</code> or <code>return</code>, the calling function
regains control. When the calling function calls <code>next()</code>, the generator
function regains starts running again. There&#39;s another way the calling function
can give control back to the generator function: the <code>throw()</code> function.</p>
<p><br><br><br><br></p>
<p>The <code>throw()</code> function is a way for the calling function to tell the generator
function that something went wrong. In the generator function, this will look
like the <code>yield</code> statement threw an error. You can then use try/catch to
handle the error in the generator function. As you&#39;ll see in the next section,
this pattern is indispensable for working with asynchronous code and generators.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fakeFibonacciGenerator = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    error; <span class="hljs-comment">// Error: Expected 1, got 3</span>
  }
};
<span class="hljs-keyword">const</span> fibonacci = fakeFibonacciGenerator();

<span class="hljs-keyword">const</span> x = fibonacci.next();
fibonacci.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Expected 1, got <span class="hljs-subst">${x.value}</span>`</span>));
<span class="hljs-comment">// { value: undefined, done: true }</span>
fibonacci.next();
</code></pre>
<h2 id="case-study-handling-async-errors">Case Study: Handling Async Errors</h2>
<p>Remember that there are two functions involved in generator functions: the
generator function itself, and the function that calls <code>next()</code> on the
generator object. So far in this book, the function that calls <code>next()</code>
hasn&#39;t done any real work. The most complex example is the async Fibonacci
example, which acted as a scheduler for the Fibonacci generator.</p>
<p>One pivotal feature of generators is that the <code>next()</code> function can take
a parameter. That parameter then becomes the return value of the <code>yield</code>
statement in the generator function itself!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> fullName = <span class="hljs-keyword">yield</span> [<span class="hljs-string">'John'</span>, <span class="hljs-string">'Smith'</span>];
  fullName; <span class="hljs-comment">// 'John Smith'</span>
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-comment">// Execute up to the first `yield`</span>
<span class="hljs-keyword">const</span> next = generator.next();
<span class="hljs-comment">// Join ['John', 'Smith'] =&gt; 'John Smith' and use it as the</span>
<span class="hljs-comment">// result of `yield`, then execute the rest of the generator function</span>
generator.next(next.value.join(<span class="hljs-string">' '</span>));
</code></pre>
<p>Once you combine this feature with the <code>throw()</code> function, you have everything
you need to have the generator function <code>yield</code> whenever it needs to do
an asynchronous operation. The calling function can then execute the
asynchronous operation, <code>throw()</code> any errors that occurred, and return the
result of the async operation using <code>next()</code>.</p>
<p><br><br><br></p>
<p>This means that your generator function doesn&#39;t need to worry about callbacks.
The calling function can be responsible for running asynchronous operations
and reporting any errors back to the generator function. For instance,
the below example shows how to run a generator function that yields an
asynchronous function without any errors.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'Hello, Async!'</span>), <span class="hljs-number">10</span>);
};

<span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> v = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">async</span>;
  v; <span class="hljs-comment">// 'Hello, Async!'</span>
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-keyword">const</span> res = generator.next();
res.value(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  generator.next(res);
});
</code></pre>
<p>Now suppose that the <code>async</code> function returns an error. The calling function
can then call <code>throw()</code> on the generator, and now your generator function
can handle this asynchronous operation with try/catch! As you&#39;ll see in the
coroutines chapter, this idea is the basis of the co library.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>)), <span class="hljs-number">10</span>);
};

<span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">async</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    error; <span class="hljs-comment">// Error: Oops!</span>
  }
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-keyword">const</span> res = generator.next();
res.value(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  generator.throw(error);
});
</code></pre>
<h1 id="chapter-2-asynchronous-coroutines">Chapter 2: Asynchronous Coroutines</h1>
<p>In chapter 1, you saw how to <code>yield</code> an asynchronous function from a generator.
The calling function would then execute the asynchronous function and resume
the generator function when the asynchronous function was done. This pattern
is an instance of an old (1958) programming concept known as a coroutine.
A <strong>coroutine</strong> is a function that can suspend its execution and defer to
another function. As you might have guessed, generator functions are coroutines,
and the <code>yield</code> statement is how a generator function defers control to another
function. You can think of a coroutine as two functions running side-by-side,
deferring control to each other at predefined points.</p>
<p>So why are coroutines special? In JavaScript, you typically need to specify a
callback for asynchronous operations. For instance, if you use the <code>superagent</code>
HTTP library to make an HTTP request to Google&#39;s home page, you would use code
similar to what you see below.</p>
<pre><code class="lang-javascript">superagent.get(<span class="hljs-string">'http://google.com'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  <span class="hljs-comment">// Handle error, use res</span>
});
</code></pre>
<p>By yielding asynchronous operations, you can write asynchronous operations
without callbacks. However, remember that a coroutine involves two functions:
the generator function, and the function that calls <code>next()</code> on the generator.
When your generator function yields an asynchronous operation, the calling
function needs to handle the asynchronous operation and resume the generator
when the asynchronous operation completes.</p>
<p>The most popular library for handling generator functions that yield
asynchronous operations is called co. Here&#39;s what getting the HTML for Google&#39;s
home page looks like in co. Looks cool, right? The below code is still
asynchronous, but looks like synchronous code. In this chapter, you&#39;ll learn
about how co works by writing your own co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
});
</code></pre>
<h2 id="promises-and-thunks">Promises and Thunks</h2>
<p>The purpose of this chapter is to build your own co. But first, there&#39;s one
key term that we need to clarify: what sort of asynchronous operations can
you yield to co? The examples you&#39;ve seen so far</p>
<p><br><br><br></p>
<p>in this book have been
cherry-picked. For instance, recall the asynchronous function from the
asynchronous errors section.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>)), <span class="hljs-number">10</span>);
};
</code></pre>
<p>The above function is asynchronous, but not representative of asynchronous
functions as a whole. For instance, the <code>superagent.get</code> function takes
a parameter as well as a callback:</p>
<pre><code class="lang-javascript">superagent.get(<span class="hljs-string">'http://google.com'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
<span class="hljs-comment">// Handle error, use res</span>
});
</code></pre>
<p>The <code>async</code> function is an example of a thunk. A <strong>thunk</strong> is an asynchronous
function that takes a single parameter, a callback. The <code>superagent.get()</code>
function is <em>not</em> a thunk, because it takes 2 parameters, a url and a callback.</p>
<p>Thunks may seem limited, but with arrow functions you can easily convert
any asynchronous function call to a thunk.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> (callback) =&gt; { superagent.get(<span class="hljs-string">'http://google.com'</span>, callback); };
});
</code></pre>
<p>There are also libraries that can convert asynchronous functions to thunks
for you. The original author of co, TJ Holowaychuk, also wrote a library called
thunkify. As the name suggests, thunkify converts a general asynchronous
function into a thunk for use with co. The <code>thunkify</code> function takes a
single parameter, an asynchronous function, and returns a function that
returns a thunk. Below is how you would use
<code>thunkify()</code> with co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
<span class="hljs-keyword">const</span> thunkify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'thunkify'</span>);

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> thunk = thunkify(superagent.get)(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-comment">// function</span>
  <span class="hljs-keyword">typeof</span> thunk;
  <span class="hljs-comment">// A function's length property contains the number of parameters</span>
  <span class="hljs-comment">// In this case, 1</span>
  thunk.length;
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> thunk;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
}).catch(error =&gt; done(error));
</code></pre>
<p><br><br></p>
<p>Thunkify may seem confusing because of the numerous layers of function
indirection. Don&#39;t worry, thunkify is not that complex, you can implement
your own in 9 lines. Below is a simple implementation of thunkify.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

<span class="hljs-keyword">const</span> thunkify = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-comment">// Thunkify returns a function that takes some arguments</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// The function gathers the arguments</span>
    <span class="hljs-keyword">const</span> args = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) {
      args.push(arg);
    }
    <span class="hljs-comment">// And returns a thunk</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-comment">// The thunk calls the original function with your arguments</span>
      <span class="hljs-comment">// plus the callback</span>
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">null</span>, args.concat([callback]));
    };
  };
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> thunk = thunkify(superagent.get)(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-comment">// </span>
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> thunk;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
});
</code></pre>
<p>If thunkify makes thunks so easy, why do you ever need anything else? As is
often the case with JavaScript, the problem is the <code>this</code> keyword.
The below example shows that when you call <code>thunkify()</code> on a function, that
function loses its value of <code>this</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
  <span class="hljs-keyword">async</span>(callback) {
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>);
  }
}

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> test = <span class="hljs-keyword">new</span> Test();
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(test.async)();
  <span class="hljs-comment">// Woops, res refers to global object rather than the `test` variable</span>
  assert.ok(res !== test);
  done();
});
</code></pre>
<p><br><br><br><br></p>
<p>Why does thunkify lose the function&#39;s value of <code>this</code>? Because the JavaScript
language spec treats calling <code>a.b();</code> different from <code>var c = a.b; c();</code>.
When you call a function as a member, like the <code>a.b();</code> case, <code>this</code> will equal
<code>a</code> in the function call. However, <code>var c = a.b; c();</code> does not call a function
as a member, so <code>this</code> refers to the global object in <code>c</code>. The latter case
also applies when you pass a function as a parameter to another function,
like you do with <code>thunkify()</code>.</p>
<p>There are ways to make thunkify work better. For instance, in the previous
example, you could use <code>.bind()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(test.async.bind(test))();
</code></pre>
<p>However, <code>bind()</code> gets to be very confusing when you have <em>chained</em> function
calls. A chained function call takes the form <code>a.b().c().d()</code>, and the <code>b()</code>,
<code>c()</code>, and <code>d()</code> function calls are &quot;chained&quot; together. This API pattern
is often used in JavaScript for building up complex objects, like HTTP requests
or MongoDB queries. For instance, superagent has a chainable API for building
up HTTP requests.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create an arbitrary complex HTTP request to show how superagent's</span>
<span class="hljs-comment">// request builder works.</span>
superagent.
  get(<span class="hljs-string">'http://google.com'</span>).
  <span class="hljs-comment">// Set the HTTP Authorization header</span>
  set(<span class="hljs-string">'Authorization'</span>, <span class="hljs-string">'MY_TOKEN_HERE'</span>).
  <span class="hljs-comment">// Only allow 5 HTTP redirects before failing</span>
  redirects(<span class="hljs-number">5</span>).
  <span class="hljs-comment">// Add `?color=blue` to the URL</span>
  query({ color: blue }).
  <span class="hljs-comment">// Send the request</span>
  end(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{});
</code></pre>
<p>Let&#39;s say you wanted to thunkify the above code. Where would you need to use
<code>.bind()</code> and what would you need to <code>bind()</code> to? The answer is not obvious
unless you read superagent&#39;s code. You need to <code>bind()</code> to
the return value of <code>superagent.get()</code>.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> req = superagent.get(<span class="hljs-string">'http://google.com'</span>);
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(req.query({ color: blue }).end.bind(req));
});
</code></pre>
<p>Thunkify and thunks in general are an excellent fallback, but co
supports a better asynchronous primitive: promises. A <strong>promise</strong> is an
object that has a <code>.then()</code> function that takes two functions as parameters.</p>
<ul>
<li><code>onFulfilled</code>: called if the asynchronous operation succeeds.</li>
<li><code>onRejected</code>: called if the asynchronous operation failed.</li>
</ul>
<p>You can think of promises as an object wrapper around a single
asynchronous operation. Once you call <code>.then()</code>, the asynchronous
operation starts. Once the asynchronous operation completes,
the promise then calls either <code>onFulfilled</code> or <code>onRejected</code>.</p>
<p><br></p>
<p>For example, each function call in the superagent
HTTP request builder returns a promise that you can <code>yield</code>.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// `superagent.get()` returns a promise, because the `.then` property</span>
  <span class="hljs-comment">// is a function.</span>
  superagent.get(<span class="hljs-string">'http://www.google.com'</span>).then;
  co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Works because co is smart enough to look for a `.then()` function</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> superagent.
      get(<span class="hljs-string">'http://www.google.com'</span>).
      query({ color: <span class="hljs-string">'blue'</span> });
  });
});
</code></pre>
<p>Much easier than using thunkify! More importantly, you don&#39;t have to worry
about messing up the value of <code>this</code> because you aren&#39;t passing a function as
a parameter. The downside of promises, though, is that you rely on the function
itself to return a promise. When you use thunkify, you make no assumptions
about the return value of the function you&#39;re calling. However, many popular
Node.js libraries, like superagent, the redis driver, and the MongoDB driver,
all have mechanisms for promise-based APIs.</p>
<p>Promises are a deep subject and what you&#39;ve seen thus far is just the tip of
the iceberg. To use co, all you need to know is that
a promise is an object with a <code>.then()</code> function that takes 2 function
parameters: <code>onFulfilled</code> and <code>onRejected</code>. For instance, below is an example
of a minimal promise that&#39;s compatible with co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> promise = {
  then: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>{
    setTimeout(() =&gt; onFulfilled(<span class="hljs-string">'Hello, World!'</span>), <span class="hljs-number">0</span>);
  }
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">yield</span> promise;
  assert.equal(str, <span class="hljs-string">'Hello, World!'</span>);
});
</code></pre>
<h2 id="write-your-own-co">Write Your Own Co</h2>
<p>Now that you&#39;ve seen how thunks and promises work, it&#39;s time to apply the
fundamentals of generators to write your own minimal implementation of co.
To avoid confusion, your version will be called &quot;fo&quot; (pronounced like &quot;faux&quot;).</p>
<p>The v1 implementation of fo is short, but will utilize all the concepts that
you&#39;ve learned thus far. You&#39;ll use generator functions, <code>generator.next()</code>,
<code>generator.throw()</code>, thunks, and promises. Ready? The
implementation is...</p>
<p><br></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">generatorFunction</span>) </span>{
  <span class="hljs-keyword">const</span> generator = generatorFunction();
  next();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">v</span>) </span>{
    <span class="hljs-keyword">const</span> res = generator.next(v);
    <span class="hljs-keyword">if</span> (res.done) {
      <span class="hljs-keyword">return</span>;
    }
    handleAsync(res.value);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAsync</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">async</span> &amp;&amp; <span class="hljs-keyword">async</span>.then) {
      handlePromise(<span class="hljs-keyword">async</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">async</span> === <span class="hljs-string">'function'</span>) {
      handleThunk(<span class="hljs-keyword">async</span>);
    } <span class="hljs-keyword">else</span> {
      generator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid yield <span class="hljs-subst">${async}</span>`</span>))
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">const</span> onRejected = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
      generator.throw(error);
    }
    <span class="hljs-keyword">async</span>.then(next, onRejected);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleThunk</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">async</span>((error, v) =&gt; {
      <span class="hljs-keyword">if</span> (error) {
        generator.throw(error);
        <span class="hljs-keyword">return</span>;
      }
      next(v);
    });
  }
};

<span class="hljs-comment">// fo in action</span>
fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
});
</code></pre>

    </div>
    <script type="text/javascript">
      var start = 3400;
      var delta = 1680;
      for (var i = 2; i < 16; ++i) {
        var height = start + (i - 2) * delta;
        document.write('<div class="page-num" style="top:' + height + 'px;">' + (i - 1) + '</div>');
      }
    </script>
  