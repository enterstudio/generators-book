
    <link href='http://fonts.googleapis.com/css?family=Titillium+Web' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
    <style>
      html {
  font-family: 'Roboto';
  font-size: 24px;
}

h1 {
  padding-top: 100px;
  page-break-before: always;
}

h2 {
  padding-top: 75px;
}

h2#write-your-own-co, h2#real-implementation-of-co {
  page-break-before: always;
}

.page-break {
  page-break-before: always;
}

h1,h2,h3,h4,p,ul,ol,pre {
  margin-left: 50px;
  margin-right: 50px;
}

pre {
  border: 1px solid #dfdfdf;
  padding: 15px;
}

code {
  font-family: 'Droid Sans Mono';
}

p, li {
  line-height: 1.5em;
}

p code {
  color: #232323;
}

li {
  margin-left: 50px;
}

a {
  color: black;
  float: right;
  text-decoration: none;
  font-weight: bold;
}

.page-num {
  position: absolute;
  right: 50px;
  font-size: 0.75em;
  font-color: #333333;
}

.cover img {
  position: relative;
  left: -250px;
  top: -8px;
  height: 1300px;
  margin: 0px;
  padding: 0px;
}

.cover .info {
  position: absolute;
  top: 1240px;
  left: -8px;
  background-color: black;
  color: white;
  height: 441px;
  width: 1500px;
}

.title {
  padding-left: 50px;
  font-family: 'Titillium Web';
  font-size: 48pt;
  font-weight: bold;
}

.author {
  padding-left: 50px;
  font-family: 'Titillium Web';
  font-size: 36pt;
  margin-top: 15px;
}

.top-triangle {
  position: absolute;
  top: 1100px;
  left: 0px;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 200px 0 0 2000px;
  border-color: transparent transparent transparent black;
}

/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-javadoc {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.css .rule .hljs-keyword,
.hljs-winutils,
.nginx .hljs-title,
.hljs-subst,
.hljs-request,
.hljs-status {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-hexcolor,
.ruby .hljs-constant {
  color: #008080;
}

.hljs-string,
.hljs-tag .hljs-value,
.hljs-phpdoc,
.hljs-dartdoc,
.tex .hljs-formula {
  color: #d14;
}

.hljs-title,
.hljs-id,
.scss .hljs-preprocessor {
  color: #900;
  font-weight: bold;
}

.hljs-list .hljs-keyword,
.hljs-subst {
  font-weight: normal;
}

.hljs-class .hljs-title,
.hljs-type,
.vhdl .hljs-literal,
.tex .hljs-command {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-tag .hljs-title,
.hljs-rules .hljs-property,
.django .hljs-tag .hljs-keyword {
  color: #000080;
  font-weight: normal;
}

.hljs-attribute,
.hljs-variable,
.lisp .hljs-body {
  color: #008080;
}

.hljs-regexp {
  color: #009926;
}

.hljs-symbol,
.ruby .hljs-symbol .hljs-string,
.lisp .hljs-keyword,
.clojure .hljs-keyword,
.scheme .hljs-keyword,
.tex .hljs-special,
.hljs-prompt {
  color: #990073;
}

.hljs-built_in {
  color: #0086b3;
}

.hljs-preprocessor,
.hljs-pragma,
.hljs-pi,
.hljs-doctype,
.hljs-shebang,
.hljs-cdata {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.diff .hljs-change {
  background: #0086b3;
}

.hljs-chunk {
  color: #aaa;
}

    </style>
    <div id="content">
      <div class="cover">
  <img src="http://i.imgur.com/nG4gisP.jpg" />
  <div class="top-triangle"></div>
  <div class="info">
    <div class="title">
      The 80/20 Guide to ES2015 Generators
    </div>
    <div class="author">
      Valeri Karpov
    </div>
  </div>
</div>

      <h1 id="table-of-contents">Table of Contents</h1>
<h3 id="how-to-use-this-book-1-1-">How To Use This Book <a href="#1">1</a></h3>
<h3 id="1-getting-started-with-generators-2-2-">1. Getting Started With Generators <a href="#2">2</a></h3>
<ol>
<li>What is a Generator? <a href="#2">2</a></li>
<li>Case Study: Async Fibonacci <a href="#4">4</a></li>
<li>For/Of Loops <a href="#6">6</a></li>
<li>Error Handling <a href="#8">8</a></li>
<li>Case Study: Handling Async Errors <a href="#9">9</a></li>
</ol>
<h3 id="2-asynchronous-coroutines-11-11-">2. Asynchronous Coroutines <a href="#11">11</a></h3>
<ol>
<li>Promises and Thunks <a href="#11">11</a></li>
<li>Write Your Own Co <a href="#17">17</a></li>
<li>Limitations <a href="#19">19</a></li>
<li>Real Implementation of Co <a href="#21">21</a></li>
</ol>
<h3 id="3-koa-and-middleware-26-26-">3. Koa and Middleware <a href="#26">26</a></h3>
<ol>
<li>The koa-compose Module <a href="#27">27</a></li>
<li>The Koa Web Framework <a href="#29">29</a></li>
<li>Limitations of koa-compose <a href="#32">32</a></li>
</ol>
<h3 id="4-transpiling">4. Transpiling</h3>
<ol>
<li>Introducing <code>regenerator</code></li>
<li>Parsing Generators With Esprima</li>
<li>Write Your Own Transpiler</li>
</ol>
<h3 id="5-moving-on">5. Moving On</h3>

      <h1 id="how-to-use-this-book">How To Use This Book</h1>
<p>This is not just another tech book that sits up on your bookshelf gathering
dust. I think of this ebook as something halfway between a blog post and
a full book: focused and concise like a blog post, in-depth and rigorous like
a pure math textbook. The purpose of this ebook is to take you from a generators
novice to someone who would be comfortable discussing co internals in 1 to 2
hours. This ebook is meant to be read in 1-2 sessions (its only 40 pages!),
although you may also choose to read one chapter at a time.</p>
<p>What is this ebook focused on?</p>
<ul>
<li>80/20 principle. There&#39;s a lot of tooling related to generators out there:
transpilers, modules, build systems, etc. This book is focused solely on
generators and other features defined in the ES2015 specification. The <strong>only</strong>
dependency is Node.js &gt;= 4.0.0 and npm.
In particular, this ebook will <strong>not</strong> use webpack, react, babel, gulp, grunt,
TypeScript, CoffeeScript, AngularJS, Dart, or any other framework,
preprocessor, or hype train.</li>
<li>The co module and asynchronous coroutines. To better understand how generators
work in an asynchronous language like JavaScript, you&#39;ll write your own
minimal version of co from scratch. Your co implementation will enable you
to write asynchronous code without callbacks. For instance,</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Make an HTTP request to google's home page</span>
  <span class="hljs-keyword">const</span> google = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://google.com'</span>)).text;
  <span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/google/i</span>;
  <span class="hljs-comment">// The number of times "Google" appears on google.com</span>
  regexp.match(google).length;
});
</code></pre>
<ul>
<li>Composing asynchronous coroutines. You&#39;ll learn about the generator-based
server-side web framework koa, and write your own minimal koa implementation.</li>
</ul>

      <h1 id="chapter-1-getting-started">Chapter 1: Getting Started</h1>
<p>Generators are a powerful new feature in ES2015. Generators are far from a
new programming construct - they first appeared in 1975 and Python has had
them since Python 2.2 in 2001. However, as you&#39;ll see, generators are
even more powerful in an event-driven language like JavaScript. In JavaScript
(assuming Node.js &gt;= 4.0.0), a <strong>generator function</strong> is defined as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
};
</code></pre>
<p>However, if you run <code>generatorFunction</code>, you&#39;ll notice that the return value
is an object.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>); };
<span class="hljs-literal">undefined</span>
&gt; generatorFunction()
{}
</code></pre><p>That&#39;s because a generator function creates and returns a <strong>generator object</strong>.
Typically, the term <strong>generator</strong> refers to a generator object rather than
a generator function. A generator object has a single function, <code>next()</code>.
If you execute the generator object&#39;s <code>next()</code> function, you&#39;ll notice
that Node.js printed &#39;Hello, World!&#39; to the screen.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>); };
<span class="hljs-literal">undefined</span>
&gt; generatorFunction()
{}
&gt; generatorFunction().next()
Hello, World!
{ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> }
&gt;
</code></pre><p>Notice that <code>next()</code> returned an object, <code>{ value: undefined, done: true }</code>.
The meaning of this object is tied to the <code>yield</code> keyword. To introduce you
to the <code>yield</code> keyword, consider the following generator function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>;
};
</code></pre>
<p><br><br><br><br><br>
<br></p>
<p>Let&#39;s see what happens when you call <code>next()</code> on the resulting generator.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>; };
<span class="hljs-literal">undefined</span>
&gt; <span class="hljs-keyword">var</span> generator = generatorFunction();
<span class="hljs-literal">undefined</span>
&gt; generator.next();
{ value: <span class="hljs-string">'Hello, World!'</span>, done: <span class="hljs-literal">false</span> }
&gt; generator.next();
{ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> }
&gt;
</code></pre><p>Notice that, the first time you call <code>generator.next()</code>, the <code>value</code> property
is equal to the string your generator function yielded. You can think of
<code>yield</code> as the generator-specific equivalent of the <code>return</code> statement.</p>
<p>You might be wondering why the return value of <code>generator.next()</code> has a <code>done</code>
property. The reason is tied to why <code>yield</code> is different from <code>return</code>.</p>
<h3 id="-yield-vs-return-"><code>yield</code> vs <code>return</code></h3>
<p>The <code>yield</code> keyword can be thought of as a <code>return</code> that allows <strong>re-entry</strong>.
In other words, once <code>return</code> executes, the currently executing function is
done forever. However, when you call <code>generator.next()</code>, the JavaScript
interpreter executes the generator function until the first <code>yield</code> statement.
When you call <code>generator.next()</code> again, the generator function picks up where
it left off. You can think of a generator as a function that can &quot;return&quot;
multiple values.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">'Hello'</span>;
  <span class="hljs-keyword">yield</span> message;
  message += <span class="hljs-string">', World!'</span>;
  <span class="hljs-keyword">yield</span> message;
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-comment">// { value: 'Hello', done: false };</span>
<span class="hljs-keyword">const</span> v1 = generator.next();
<span class="hljs-comment">// { value: 'Hello, World!', done: false }</span>
<span class="hljs-keyword">const</span> v2 = generator.next();
<span class="hljs-comment">// { value: undefined, done: true }</span>
<span class="hljs-keyword">const</span> v3 = generator.next();
</code></pre>
<h3 id="re-entry">Re-entry</h3>
<p>The most important detail from the above example is that, when <code>yield</code>
executes, the generator function stops executing until the next time you call
<code>generator.next()</code>. You can call <code>generator.next()</code> whenever you want, even in
a <code>setTimeout()</code>. The JavaScript interpreter will re-enter the generator
function with the same state that it left off with.</p>
<p><br>
<br></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>) {
    <span class="hljs-keyword">yield</span> i;
    ++i;
  }
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-keyword">let</span> x = generator.next(); <span class="hljs-comment">// { value: 0, done: false }</span>
setTimeout(() =&gt; {
  x = generator.next(); <span class="hljs-comment">// { value: 1, done: false }</span>
  x = generator.next(); <span class="hljs-comment">// { value: 2, done: false }</span>
  x = generator.next(); <span class="hljs-comment">// { value: undefined, done: true }</span>
}, <span class="hljs-number">50</span>);
</code></pre>
<h3 id="-yield-vs-return-revisited"><code>yield</code> vs <code>return</code> revisited</h3>
<p>You may be wondering what happens when you use <code>return</code>
instead of <code>yield</code> in a generator. As you might expect,
<code>return</code> behaves similarly to <code>yield</code>, except for
<code>done</code> is set to true.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, World!'</span>;
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-comment">// { value: 'Hello, World!', done: true }</span>
<span class="hljs-keyword">const</span> v = generator.next();
</code></pre>
<h2 id="case-study-async-fibonacci">Case Study: Async Fibonacci</h2>
<p>The fact that you can execute <code>generator.next()</code> asynchronously hints at
why generators are so useful. You can execute <code>generator.next()</code> synchronously
or asynchronously without changing the implementation of the generator
function.</p>
<p><div class="page-break"></div>
<br><br></p>
<p>For instance, lets say you wrote a generator
function that computes the Fibonacci Sequence. Note that generator functions
can take parameters like any function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacciGenerator = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">let</span> back2 = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> back1 = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) {
    cur = back2 + back1;
    back2 = back1;
    back1 = cur;
    <span class="hljs-keyword">yield</span> cur;
  }

  <span class="hljs-keyword">return</span> cur;
};
</code></pre>
<p>You could compute the n-th Fibonacci number synchronously using the code
below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-keyword">let</span> it;
<span class="hljs-keyword">for</span> (it = fibonacci.next(); !it.done; it = fibonacci.next()) {}
it.value; <span class="hljs-comment">// 55, the 10th fibonacci number</span>
</code></pre>
<p>However, computing the n-th Fibonacci number synchronously is not a hard
problem without generators. To make things interesting, let&#39;s say you wanted
to compute a very large Fibonacci number <strong>without blocking the event loop</strong>.
Normally, a JavaScript for loop would block the event loop. In other words,
no other JavaScript code can execute until the for loop in the previous
example is done. This can get problematic if you want to compute the 100
millionth Fibonacci number in an Express route handler. Without generators,
breaking up a long-running calculation can be cumbersome.</p>
<p>However, since you have a generator function that yields after each iteration
of the for loop, you can call <code>generator.next()</code> in a <code>setInterval()</code>
function. This will compute the next Fibonacci number with each iteration of
the event loop, and so won&#39;t prevent Node.js from responding from incoming
requests. You can make your Fibonacci calculation asynchronous without
changing the generator function!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-comment">// And compute one new Fibonacci number with each iteration</span>
<span class="hljs-comment">// through the event loop.</span>
<span class="hljs-keyword">const</span> interval = setInterval(() =&gt; {
  <span class="hljs-keyword">const</span> res = fibonacci.next();
  <span class="hljs-keyword">if</span> (res.done) {
    clearInterval(interval);
    res.value; <span class="hljs-comment">// 55, the 10th fibonacci number</span>
  }
}, <span class="hljs-number">0</span>);
</code></pre>
<h2 id="for-of-loops">For/Of Loops</h2>
<p>Remember the for loop you saw for exhausting the Fibonacci generator?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (it = fibonacci.next(); !it.done; it = fibonacci.next()) {}
</code></pre>
<p>This for loop is a perfectly reasonable way of going through every value of
the generator. However, ES2015 introduces a much cleaner mechanism for
looping through generators: the <code>for-of</code> loop.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  x; <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
</code></pre>
<h3 id="iterators-and-iterables">Iterators and Iterables</h3>
<p>For/Of loops aren&#39;t just for generators. A generator is actually an instance
of a more general ES2015 concept called an iterator. An <strong>iterator</strong> is
any JavaScript object that has a <code>next()</code> function that returns
<code>{ value: Any, done: Boolean }</code>. A generator is one example of an iterator.
You can also iterate over arrays:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) {
  x; <span class="hljs-comment">// 1, 2, 3</span>
}
</code></pre>
<p>However, For/Of loops don&#39;t operate on iterators, they operate on iterables.
An <strong>iterable</strong> is an object that has a <code>Symbol.iterator</code> property which is
a function that returns an iterator. In other words, when you execute a
For/Of loop, the JavaScript interpreter looks for a <code>Symbol.iterator</code> property
on the object you&#39;re looping <code>of</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> iterable = {};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {} <span class="hljs-comment">// Throws an error</span>

<span class="hljs-comment">// But once you add a Symbol.iterator property, everything works!</span>
iterable[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fibonacciGenerator(<span class="hljs-number">10</span>);
};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {
  x; <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
</code></pre>
<h3 id="a-brief-overview-of-symbols">A Brief Overview of Symbols</h3>
<p><strong>Symbols</strong> are another new feature in ES2015. Since this book is about
generators, we won&#39;t explore symbols in depth, just enough to understand
what the mysterious <code>iterable[Symbol.iterator]</code> code in the previous example
is about.</p>
<p><br><br><br></p>
<p>You can think of a symbol as a unique identifier for a key on an object.
For instance, suppose you wrote your own programming language and defined
an iterable as an object that had a property named <code>iterator</code>. Now, every
object that has a property named <code>iterator</code> would be an iterable, which
could lead to some unpredictable behavior. For instance, suppose you added
a property named <code>iterator</code> to an array - now you&#39;ve accidentally broken
for/of loops for that array!</p>
<p>Symbols protect you from the issue of accidental string collision. No string
key is equal to <code>Symbol.iterator</code>, so you don&#39;t have to worry about
accidentally breaking an iterable. Furthermore, symbols don&#39;t appear in
the output of <code>Object.keys()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">Symbol</span>.iterator; <span class="hljs-comment">// Symbol(Symbol.iterator)</span>

<span class="hljs-keyword">let</span> iterable = {};
iterable[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fibonacciGenerator(<span class="hljs-number">10</span>);
};

iterable.iterator; <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Object</span>.keys(iterable); <span class="hljs-comment">// Empty array!</span>
</code></pre>
<h3 id="iterables-and-generators">Iterables and Generators</h3>
<p>The most important detail to note about generators and iterables is that
<em>generator objects</em> are iterables, not <em>generator functions</em>. In order words,
you can&#39;t run a for/of loop on a generator function.</p>
<pre><code class="lang-javascript">fibonacciGenerator[<span class="hljs-built_in">Symbol</span>.iterable]; <span class="hljs-comment">// Undefined</span>
fibonacciGenerator(<span class="hljs-number">10</span>)[<span class="hljs-built_in">Symbol</span>.iterable]; <span class="hljs-comment">// Function</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacciGenerator) {} <span class="hljs-comment">// Error!</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacciGenerator(<span class="hljs-number">10</span>)) {} <span class="hljs-comment">// Ok</span>
</code></pre>
<p>You may find it strange that the generator&#39;s
<code>Symbol.iterator</code> function returns itself given that generator functions are
not iterable. One reason for this decision is that a generator function can
take parameters. For instance, looping over <code>fibonacciGenerator(10)</code> would not
give the same results as looping over <code>fibonacciGenerator(11)</code>.</p>
<p>The second most important detail to note about generators and iterables
is that <code>generator[Symbol.iterator]</code> is a function that returns the
generator itself. This means that you can&#39;t loop over the same generator
twice. Once a generator is done, subsequent for/of loops will exit immediately.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
fibonacci[<span class="hljs-built_in">Symbol</span>.iterator]() === fibonacci; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  <span class="hljs-comment">// Doesn't run!</span>
}
</code></pre>
<h2 id="error-handling">Error Handling</h2>
<p>One detail that has been glossed over so far is how generators handle
exceptions. What happens when you divide by zero in a generator? As you
might have guessed, the <code>generator.next()</code> call throws an error.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops!'</span>);
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-comment">// throws an error</span>
generator.next();
</code></pre>
<p>The error&#39;s stack trace reflects the fact that <code>next()</code> was the function
that called the function that threw the error. In particular, if you call
<code>next()</code> asynchronously, you will lose the original stack trace.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops!'</span>);
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

setTimeout(() =&gt; {
  <span class="hljs-keyword">try</span> {
    generator.next();
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">/**
     * Error: oops!
     * at generatorFunction (book.js:2:15)
     * at next (native)
     * at null._onTimeout (book.js:18:21)
     * at Timer.listOnTimeout (timers.js:89:15)
     */</span>
    err.stack;
  }
}, <span class="hljs-number">0</span>);
</code></pre>
<h3 id="re-entry-with-error">Re-entry With Error</h3>
<p>When you think of generators, you need to think of 2 functions: the generator
function itself, and the function that&#39;s calling <code>next()</code> on the generator.
When the generator function calls <code>yield</code> or <code>return</code>, the calling function
regains control. When the calling function calls <code>next()</code>, the generator
function regains starts running again. There&#39;s another way the calling function
can give control back to the generator function: the <code>throw()</code> function.</p>
<p><br><br><br><br></p>
<p>The <code>throw()</code> function is a way for the calling function to tell the generator
function that something went wrong. In the generator function, this will look
like the <code>yield</code> statement threw an error. You can then use try/catch to
handle the error in the generator function. As you&#39;ll see in the next section,
this pattern is indispensable for working with asynchronous code and generators.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fakeFibonacciGenerator = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    error; <span class="hljs-comment">// Error: Expected 1, got 3</span>
  }
};
<span class="hljs-keyword">const</span> fibonacci = fakeFibonacciGenerator();

<span class="hljs-keyword">const</span> x = fibonacci.next();
fibonacci.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Expected 1, got <span class="hljs-subst">${x.value}</span>`</span>));
<span class="hljs-comment">// { value: undefined, done: true }</span>
fibonacci.next();
</code></pre>
<h2 id="case-study-handling-async-errors">Case Study: Handling Async Errors</h2>
<p>Remember that there are two functions involved in generator functions: the
generator function itself, and the function that calls <code>next()</code> on the
generator object. So far in this book, the function that calls <code>next()</code>
hasn&#39;t done any real work. The most complex example is the async Fibonacci
example, which acted as a scheduler for the Fibonacci generator.</p>
<p>One pivotal feature of generators is that the <code>next()</code> function can take
a parameter. That parameter then becomes the return value of the <code>yield</code>
statement in the generator function itself!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> fullName = <span class="hljs-keyword">yield</span> [<span class="hljs-string">'John'</span>, <span class="hljs-string">'Smith'</span>];
  fullName; <span class="hljs-comment">// 'John Smith'</span>
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-comment">// Execute up to the first `yield`</span>
<span class="hljs-keyword">const</span> next = generator.next();
<span class="hljs-comment">// Join ['John', 'Smith'] =&gt; 'John Smith' and use it as the</span>
<span class="hljs-comment">// result of `yield`, then execute the rest of the generator function</span>
generator.next(next.value.join(<span class="hljs-string">' '</span>));
</code></pre>
<p>Once you combine this feature with the <code>throw()</code> function, you have everything
you need to have the generator function <code>yield</code> whenever it needs to do
an asynchronous operation. The calling function can then execute the
asynchronous operation, <code>throw()</code> any errors that occurred, and return the
result of the async operation using <code>next()</code>.</p>
<p><br><br><br></p>
<p>This means that your generator function doesn&#39;t need to worry about callbacks.
The calling function can be responsible for running asynchronous operations
and reporting any errors back to the generator function. For instance,
the below example shows how to run a generator function that yields an
asynchronous function without any errors.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'Hello, Async!'</span>), <span class="hljs-number">10</span>);
};

<span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> v = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">async</span>;
  v; <span class="hljs-comment">// 'Hello, Async!'</span>
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-keyword">const</span> res = generator.next();
res.value(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  generator.next(res);
});
</code></pre>
<p>Now suppose that the <code>async</code> function returns an error. The calling function
can then call <code>throw()</code> on the generator, and now your generator function
can handle this asynchronous operation with try/catch! As you&#39;ll see in the
coroutines chapter, this idea is the basis of the co library.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>)), <span class="hljs-number">10</span>);
};

<span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">async</span>;
  } <span class="hljs-keyword">catch</span> (error) {
    error; <span class="hljs-comment">// Error: Oops!</span>
  }
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-keyword">const</span> res = generator.next();
res.value(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  generator.throw(error);
});
</code></pre>
<h1 id="chapter-2-asynchronous-coroutines">Chapter 2: Asynchronous Coroutines</h1>
<p>In chapter 1, you saw how to <code>yield</code> an asynchronous function from a generator.
The calling function would then execute the asynchronous function and resume
the generator function when the asynchronous function was done. This pattern
is an instance of an old (1958) programming concept known as a coroutine.
A <strong>coroutine</strong> is a function that can suspend its execution and defer to
another function. As you might have guessed, generator functions are coroutines,
and the <code>yield</code> statement is how a generator function defers control to another
function. You can think of a coroutine as two functions running side-by-side,
deferring control to each other at predefined points.</p>
<p>So why are coroutines special? In JavaScript, you typically need to specify a
callback for asynchronous operations. For instance, if you use the <code>superagent</code>
HTTP library to make an HTTP request to Google&#39;s home page, you would use code
similar to what you see below.</p>
<pre><code class="lang-javascript">superagent.get(<span class="hljs-string">'http://google.com'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
  <span class="hljs-comment">// Handle error, use res</span>
});
</code></pre>
<p>By yielding asynchronous operations, you can write asynchronous operations
without callbacks. However, remember that a coroutine involves two functions:
the generator function, and the function that calls <code>next()</code> on the generator.
When your generator function yields an asynchronous operation, the calling
function needs to handle the asynchronous operation and resume the generator
when the asynchronous operation completes.</p>
<p>The most popular library for handling generator functions that yield
asynchronous operations is called co. Here&#39;s what getting the HTML for Google&#39;s
home page looks like in co. Looks cool, right? The below code is still
asynchronous, but looks like synchronous code. In this chapter, you&#39;ll learn
about how co works by writing your own co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
});
</code></pre>
<h2 id="promises-and-thunks">Promises and Thunks</h2>
<p>The purpose of this chapter is to build your own co. But first, there&#39;s one
key term that we need to clarify: what sort of asynchronous operations can
you yield to co? The examples you&#39;ve seen so far</p>
<p><br><br><br></p>
<p>in this book have been
cherry-picked. For instance, recall the asynchronous function from the
asynchronous errors section.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
  setTimeout(() =&gt; callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Oops!'</span>)), <span class="hljs-number">10</span>);
};
</code></pre>
<p>The above function is asynchronous, but not representative of asynchronous
functions as a whole. For instance, the <code>superagent.get</code> function takes
a parameter as well as a callback:</p>
<pre><code class="lang-javascript">superagent.get(<span class="hljs-string">'http://google.com'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{
<span class="hljs-comment">// Handle error, use res</span>
});
</code></pre>
<p>The <code>async</code> function is an example of a thunk. A <strong>thunk</strong> is an asynchronous
function that takes a single parameter, a callback. The <code>superagent.get()</code>
function is <em>not</em> a thunk, because it takes 2 parameters, a url and a callback.</p>
<p>Thunks may seem limited, but with arrow functions you can easily convert
any asynchronous function call to a thunk.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> (callback) =&gt; { superagent.get(<span class="hljs-string">'http://google.com'</span>, callback); };
});
</code></pre>
<p>There are also libraries that can convert asynchronous functions to thunks
for you. The original author of co, TJ Holowaychuk, also wrote a library called
thunkify. As the name suggests, thunkify converts a general asynchronous
function into a thunk for use with co. The <code>thunkify</code> function takes a
single parameter, an asynchronous function, and returns a function that
returns a thunk. Below is how you would use
<code>thunkify()</code> with co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
<span class="hljs-keyword">const</span> thunkify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'thunkify'</span>);

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> thunk = thunkify(superagent.get)(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-comment">// function</span>
  <span class="hljs-keyword">typeof</span> thunk;
  <span class="hljs-comment">// A function's length property contains the number of parameters</span>
  <span class="hljs-comment">// In this case, 1</span>
  thunk.length;
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> thunk;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
}).catch(error =&gt; done(error));
</code></pre>
<p><br><br></p>
<p>Thunkify may seem confusing because of the numerous layers of function
indirection. Don&#39;t worry, thunkify is not that complex, you can implement
your own in 9 lines. Below is a simple implementation of thunkify.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

<span class="hljs-keyword">const</span> thunkify = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-comment">// Thunkify returns a function that takes some arguments</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// The function gathers the arguments</span>
    <span class="hljs-keyword">const</span> args = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) {
      args.push(arg);
    }
    <span class="hljs-comment">// And returns a thunk</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-comment">// The thunk calls the original function with your arguments</span>
      <span class="hljs-comment">// plus the callback</span>
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">null</span>, args.concat([callback]));
    };
  };
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> thunk = thunkify(superagent.get)(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-comment">// </span>
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> thunk;
  <span class="hljs-comment">// HTML for Google's home page</span>
  html;
});
</code></pre>
<p>If thunkify makes thunks so easy, why do you ever need anything else? As is
often the case with JavaScript, the problem is the <code>this</code> keyword.
The below example shows that when you call <code>thunkify()</code> on a function, that
function loses its value of <code>this</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
  <span class="hljs-keyword">async</span>(callback) {
    <span class="hljs-keyword">return</span> callback(<span class="hljs-literal">null</span>, <span class="hljs-keyword">this</span>);
  }
}

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> test = <span class="hljs-keyword">new</span> Test();
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(test.async)();
  <span class="hljs-comment">// Woops, res refers to global object rather than the `test` variable</span>
  assert.ok(res !== test);
  done();
});
</code></pre>
<p><br><br><br><br></p>
<p>Why does thunkify lose the function&#39;s value of <code>this</code>? Because the JavaScript
language spec treats calling <code>a.b();</code> different from <code>var c = a.b; c();</code>.
When you call a function as a member, like the <code>a.b();</code> case, <code>this</code> will equal
<code>a</code> in the function call. However, <code>var c = a.b; c();</code> does not call a function
as a member, so <code>this</code> refers to the global object in <code>c</code>. The latter case
also applies when you pass a function as a parameter to another function,
like you do with <code>thunkify()</code>.</p>
<p>There are ways to make thunkify work better. For instance, in the previous
example, you could use <code>.bind()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(test.async.bind(test))();
</code></pre>
<p>However, <code>bind()</code> gets to be very confusing when you have <em>chained</em> function
calls. A chained function call takes the form <code>a.b().c().d()</code>, and the <code>b()</code>,
<code>c()</code>, and <code>d()</code> function calls are &quot;chained&quot; together. This API pattern
is often used in JavaScript for building up complex objects, like HTTP requests
or MongoDB queries. For instance, superagent has a chainable API for building
up HTTP requests.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create an arbitrary complex HTTP request to show how superagent's</span>
<span class="hljs-comment">// request builder works.</span>
superagent.
  get(<span class="hljs-string">'http://google.com'</span>).
  <span class="hljs-comment">// Set the HTTP Authorization header</span>
  set(<span class="hljs-string">'Authorization'</span>, <span class="hljs-string">'MY_TOKEN_HERE'</span>).
  <span class="hljs-comment">// Only allow 5 HTTP redirects before failing</span>
  redirects(<span class="hljs-number">5</span>).
  <span class="hljs-comment">// Add `?color=blue` to the URL</span>
  query({ color: blue }).
  <span class="hljs-comment">// Send the request</span>
  end(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, res</span>) </span>{});
</code></pre>
<p>Let&#39;s say you wanted to thunkify the above code. Where would you need to use
<code>.bind()</code> and what would you need to <code>bind()</code> to? The answer is not obvious
unless you read superagent&#39;s code. You need to <code>bind()</code> to
the return value of <code>superagent.get()</code>.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> req = superagent.get(<span class="hljs-string">'http://google.com'</span>);
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> thunkify(req.query({ color: blue }).end.bind(req));
});
</code></pre>
<p>Thunkify and thunks in general are an excellent fallback, but co
supports a better asynchronous primitive: promises. A <strong>promise</strong> is an
object that has a <code>.then()</code> function that takes two functions as parameters.</p>
<ul>
<li><code>onFulfilled</code>: called if the asynchronous operation succeeds.</li>
<li><code>onRejected</code>: called if the asynchronous operation failed.</li>
</ul>
<p><br><br><br><br></p>
<p>You can think of promises as an object wrapper around a single
asynchronous operation. Once you call <code>.then()</code>, the asynchronous
operation starts. Once the asynchronous operation completes,
the promise then calls either <code>onFulfilled</code> or <code>onRejected</code>.</p>
<p>For example, each function call in the superagent
HTTP request builder returns a promise that you can <code>yield</code>.</p>
<pre><code class="lang-javascript">co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// `superagent.get()` returns a promise, because the `.then` property</span>
  <span class="hljs-comment">// is a function.</span>
  superagent.get(<span class="hljs-string">'http://www.google.com'</span>).then;
  co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Works because co is smart enough to look for a `.then()` function</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> superagent.
      get(<span class="hljs-string">'http://www.google.com'</span>).
      query({ color: <span class="hljs-string">'blue'</span> });
  });
});
</code></pre>
<p>Much easier than using thunkify! More importantly, you don&#39;t have to worry
about messing up the value of <code>this</code> because you aren&#39;t passing a function as
a parameter. The downside of promises, though, is that you rely on the function
itself to return a promise. When you use thunkify, you make no assumptions
about the return value of the function you&#39;re calling. However, many popular
Node.js libraries, like superagent, the redis driver, and the MongoDB driver,
all have the ability to return promises for asynchronous operations.</p>
<p>Creating your own promises is easy. Promises are a core part of ES2015, so
you don&#39;t have to include any libraries. Below is an example of how to create
an ES2015 promise. The <code>Promise</code> constructor takes a single function,
called a <strong>resolver</strong>, which takes two function parameters, <code>resolve</code> and
<code>reject</code>. The resolver is responsible for executing the asynchronous
operation and calling <code>resolve()</code> if the operation succeeded or <code>reject()</code>
if it failed.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// The resolver function takes 2 parameters, a `resolve()` function</span>
<span class="hljs-comment">// and a `reject()` function.</span>
<span class="hljs-keyword">const</span> resolver = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-comment">// Call `resolve()` asynchronously with a value</span>
  setTimeout(() =&gt; resolve(<span class="hljs-string">'Hello, World!'</span>), <span class="hljs-number">5</span>);
};
<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolver);
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>{
  <span class="hljs-comment">// The promise's `onFulfilled` function gets called with</span>
  <span class="hljs-comment">// the value the resolver passed to `resolve()`. In this</span>
  <span class="hljs-comment">// case, the string 'Hello, World!'</span>
  res;
});
</code></pre>
<p><br><br><br><br><br></p>
<p>Promises are a deep subject and what you&#39;ve seen thus far is just the tip of
the iceberg. To use co, all you need to know is that
a promise is an object with a <code>.then()</code> function that takes 2 function
parameters: <code>onFulfilled</code> and <code>onRejected</code>. For instance, below is an example
of a minimal promise that&#39;s compatible with co.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> promise = {
  then: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>{
    setTimeout(() =&gt; onFulfilled(<span class="hljs-string">'Hello, World!'</span>), <span class="hljs-number">0</span>);
  }
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">yield</span> promise;
  assert.equal(str, <span class="hljs-string">'Hello, World!'</span>);
});
</code></pre>
<h2 id="write-your-own-co">Write Your Own Co</h2>
<p>Now that you&#39;ve seen how thunks and promises work, it&#39;s time to apply the
fundamentals of generators to write your own minimal implementation of co.
To avoid confusion, your version will be called &quot;fo&quot; (pronounced like &quot;faux&quot;).</p>
<p>The v1 implementation of fo is short, but will utilize all the concepts that
you&#39;ve learned thus far. You&#39;ll use generator functions, <code>generator.next()</code>,
<code>generator.throw()</code>, thunks, and promises. Ready? The
implementation is...</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">generatorFunction</span>) </span>{
  <span class="hljs-keyword">const</span> generator = generatorFunction();
  next();

  <span class="hljs-comment">// Call next() or throw() on the generator as necessary</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">v, isError</span>) </span>{
    <span class="hljs-keyword">const</span> res = isError ? generator.throw(v) : generator.next(v);
    <span class="hljs-keyword">if</span> (res.done) {
      <span class="hljs-keyword">return</span>;
    }
    handleAsync(res.value);
  }

  <span class="hljs-comment">// Handle the result the generator yielded</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAsync</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">async</span> &amp;&amp; <span class="hljs-keyword">async</span>.then) {
      handlePromise(<span class="hljs-keyword">async</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">async</span> === <span class="hljs-string">'function'</span>) {
      handleThunk(<span class="hljs-keyword">async</span>);
    } <span class="hljs-keyword">else</span> {
      next(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid yield <span class="hljs-subst">${async}</span>`</span>), <span class="hljs-literal">true</span>);
    }
  }

  <span class="hljs-comment">// If the generator yielded a promise, call `.then()`</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handlePromise</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">async</span>.then(next, (error) =&gt; next(error, <span class="hljs-literal">true</span>));
  }

  <span class="hljs-comment">// If the generator yielded a thunk, call it</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleThunk</span>(<span class="hljs-params">async</span>) </span>{
    <span class="hljs-keyword">async</span>((error, v) =&gt; {
      error ? next(error, <span class="hljs-literal">true</span>) : next(v);
    });
  }
};

<span class="hljs-comment">// fo in action</span>
fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
});
</code></pre>
<p><br><br><br></p>
<p>Let&#39;s take a closer look at how the <code>fo()</code> function works. The first step is
to create a generator from the provided generator function. Once you have
a generator, you need to use the <code>next()</code> function to kick off the generator&#39;s
execution. The <code>next()</code> function calls <code>generator.next()</code> to start off the
generator. Any time the generator yields, the <code>fo()</code> function calls
<code>handleAsync()</code>, which is responsible for handling the asynchronous operations
the generator yields. In particular, <code>handlePromise()</code> handles any promises
that the generator yields, and <code>handleThunk()</code> handles any thunks.</p>
<p>Let&#39;s see how <code>fo()</code> works with a simple error. In the below example, you make
an HTTP request to a nonexistent URL. Superagent will fail, and so the
promise calls its <code>onRejected()</code> function. The <code>fo()</code> function will then call
<code>next()</code> with <code>isError</code> set to true. The internal <code>next()</code> function then
calls <code>generator.throw()</code> to trigger an error in the generator, which you
can then try/catch.</p>
<pre><code class="lang-javascript">fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// First iteration of `next()` stops here,</span>
    <span class="hljs-comment">// calls `.then()` on the promise</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://doesnot.exist.baddomain'</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// The promise was rejected, so fo calls `generator.throw()` and</span>
    <span class="hljs-comment">// you end up here.</span>
  }

  <span class="hljs-comment">// Second iteration of `next()` stops here, `.then()` on the promise</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  res.text;
  <span class="hljs-comment">// Third iteration of `next()` stops here because generator is done</span>
});
</code></pre>
<p>One neat pattern that illustrates the power of asynchronous coroutines is
retrying failed HTTP requests. If the server you&#39;re trying to reach is
unreliable, you may want to retry requests a fixed number of times before
giving up. Without generators, retrying requests involves a lot of recursion
and careful design decisions.
With generators and <code>fo()</code> (or co), all you need to retry requests
is a for loop as shown below.</p>
<pre><code class="lang-javascript">fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">'http://doesnot.exist.baddomain'</span>;
  <span class="hljs-keyword">const</span> NUM_RETRIES = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">let</span> res;
  <span class="hljs-keyword">let</span> i;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Going to yield 3 times, and `fo()` will call `generator.throw()`</span>
      <span class="hljs-comment">// 3 times because superagent will fail every time</span>
      res = <span class="hljs-keyword">yield</span> superagent.get(url);
    } <span class="hljs-keyword">catch</span> (error) { <span class="hljs-comment">/* retry */</span> }
  }

  <span class="hljs-comment">// res is undefined - retried 3 times with no results</span>
});
</code></pre>
<h2 id="limitations">Limitations</h2>
<p>The v1 implementation of fo is simple, clean, and gets you 80% of the way
to writing your own co. However, co has several subtle features that become
indispensable when you try to write a real application.</p>
<p>One particular edge case that we glossed over in the &quot;Write Your Own Co&quot;
section is what happens when there&#39;s an uncaught error in the generator.
In the v1 implementation of fo, the uncaught error will crash the process.
Crashing the process isn&#39;t the worst possible behavior, but, as you&#39;ll see in
the &quot;Real Implementation of Co&quot; section, co provides a neat way to catch
any uncaught errors in the generator function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">try</span> {
  fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// This will throw an uncaught asynchronous exception</span>
    <span class="hljs-comment">// and crash the process!</span>
    <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://doesnot.exist.baddomain'</span>);
  });
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-comment">// This try/catch won't catch the error within the `fo()` call!</span>
}
</code></pre>
<p>Another limitation is the ability to use helper functions that yield. For
instance, suppose you wanted to write a <code>retry()</code> helper function that
retried an asynchronous operation a fixed number of times for you.
You might try implementing retry as a plain old function
(as opposed to a generator function) and then quickly realize that you can&#39;t
yield from a normal function. You might then try implementing
the <code>retry()</code> function as shown below. But alas! Your <code>fo()</code> v1 doesn&#39;t
supporting yielding generators! </p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Needs to be a generator function so you can `yield` in it.</span>
<span class="hljs-keyword">const</span> retry = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">fn, numRetries</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numRetries; ++i) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> fn();
      <span class="hljs-keyword">return</span> res;
    } <span class="hljs-keyword">catch</span> (error) {}
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Retried <span class="hljs-subst">${numRetries}</span> times`</span>);
};

fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">'http://www.google.com'</span>;
  <span class="hljs-comment">// Fo's `handleAsync` function will throw because you're</span>
  <span class="hljs-comment">// yielding a generator function!</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> retry(() =&gt; superagent.get(url), <span class="hljs-number">3</span>);
});
</code></pre>
<p><br><br><br><br></p>
<p>Finally, fo v1 doesn&#39;t allow any parallelism. Asynchronous operations must
be executed one after the other, there&#39;s no way to execute 2 requests in
parallel. Suppose you wanted to load Google and Amazon&#39;s home pages in parallel
as shown below. As you&#39;ll see in the &quot;Real Implementation of Co&quot; section,
co gives you a convenient mechanism to execute requests in
parallel.</p>
<pre><code class="lang-javascript">fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> google = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-keyword">const</span> amazon = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.amazon.com'</span>);
});
</code></pre>
<h2 id="real-implementation-of-co">Real Implementation of Co</h2>
<p>The key decision that makes co 4.x overcome all the limitations of fo v1 is
that the <code>co()</code> function itself returns a promise, and converts all
asynchronous operations into promises. If fo() returns a promise, then you
can handle the case where the generator yields a generator function by just
calling fo() on the yielded generator function. Promises also provide a
mechanism for handling errors: the <code>reject()</code> function. You can wrap your
calls to <code>generator.next()</code> and <code>generator.throw()</code> in a try/catch, and reject
the promise if the generator threw. Below is the implementation of fo v2,
which uses promises internally and returns a promise.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>{
  <span class="hljs-keyword">const</span> isGenerator = (v) =&gt; <span class="hljs-keyword">typeof</span> v.next === <span class="hljs-string">'function'</span>;
  <span class="hljs-keyword">const</span> isGeneratorFunction =
    (v) =&gt; v.constructor &amp;&amp; v.constructor.name === <span class="hljs-string">'GeneratorFunction'</span>;

  <span class="hljs-keyword">let</span> generator;
  <span class="hljs-keyword">if</span> (isGenerator(input)) generator = input;
  <span class="hljs-keyword">if</span> (isGeneratorFunction(input)) generator = input();
  <span class="hljs-keyword">if</span> (!generator) <span class="hljs-keyword">throw</span> <span class="hljs-string">`Invalid parameter to fo() <span class="hljs-subst">${input}</span>`</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
    next();

    <span class="hljs-comment">// Call next() or throw() on the generator as necessary</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params">v, isError</span>) </span>{
      <span class="hljs-keyword">let</span> res;
      <span class="hljs-keyword">try</span> {
        res = isError ? generator.throw(v) : generator.next(v);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">return</span> reject(error);
      }
      <span class="hljs-keyword">if</span> (res.done) {
        <span class="hljs-keyword">return</span> resolve(res.value);
      }
      toPromise(res.value).then(next, (error) =&gt; next(error, <span class="hljs-literal">true</span>));
    }

    <span class="hljs-comment">// Convert v to a promise. If invalid, returns a rejected promise</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toPromise</span>(<span class="hljs-params">v</span>) </span>{
      <span class="hljs-keyword">if</span> (isGeneratorFunction(v) || isGenerator(v)) <span class="hljs-keyword">return</span> fo(v);
      <span class="hljs-keyword">if</span> (v.then) <span class="hljs-keyword">return</span> v;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
          v((error, res) =&gt; error ? reject(error) : resolve(res));
        });
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(v)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(v.map(toPromise));
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid yield <span class="hljs-subst">${v}</span>`</span>));
    }
  });
};
</code></pre>
<p><br><br></p>
<p>Let&#39;s take a look at how this new version of fo resolves the major limitations
of the first version. First off, let&#39;s take a look at error handling. The key
idea for error handling in fo is the below code.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> res;
<span class="hljs-keyword">try</span> {
  res = isError ? generator.throw(v) : generator.next(v);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-keyword">return</span> reject(error);
}
</code></pre>
<p>The <code>fo()</code> function may be asynchronous, but every error that can occur in your
generator function happens synchronously in the above try block. For instance,
suppose you made an HTTP request to a bad URL and didn&#39;t wrap your
<code>superagent.get()</code> call in a try/catch. In that case, fo will reject the
promise and trigger your <code>onRejected</code> handler.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://doesnot.exist.baddomain'</span>);
}).then(<span class="hljs-literal">null</span>, (error) =&gt; {
  <span class="hljs-comment">// Caught the HTTP error!</span>
});
</code></pre>
<p>ES2015 promises have a handy helper function called <code>.catch()</code>. While <code>catch()</code>
may sound intimidating, it is just a convenient shorthand for <code>.then()</code> with
no <code>onFulfilled</code> handler. In other words using <code>.catch()</code> as shown below:</p>
<pre><code class="lang-javascript">promise.catch(errorHandler);
</code></pre>
<p>is just a convenient shorthand for the below code.</p>
<pre><code class="lang-javascript">promise.then(<span class="hljs-literal">null</span>, errorHandler);
</code></pre>
<p>Below is the previous example re-written to use <code>.catch()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://doesnot.exist.baddomain'</span>);
}).catch((error) =&gt; {
  <span class="hljs-comment">// Caught the HTTP error!</span>
});
</code></pre>
<p><br><br><br><br><br><br></p>
<p>Fo&#39;s error handling abilities aren&#39;t limited to asynchronous errors. Since you
wrapped <code>generator.next()</code> in a try/catch, fo reports <strong>any</strong> uncaught errors
that occur when executing the generator to your <code>onRejected</code> handler. For
instance, say you accidentally access a nonexistent property and get the
dreaded <code>TypeError: Cannot read property &#39;X&#39; of undefined</code> error. Fo will
report that error to <code>onRejected</code> as well!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  <span class="hljs-comment">// Throws a TypeError, because `html.notARealProperty` is undefined</span>
  <span class="hljs-keyword">const</span> v = html.notARealProperty.test;
}).catch((error) =&gt; {
  <span class="hljs-comment">// Caught the TypeError!</span>
});
</code></pre>
<p>The new implementation of fo also enables you to yield generators and
generator functions. Since <code>fo()</code> returns a promise, all you need to do is
detect when the generator yields another generator and use <code>fo()</code> to convert
that generator to a promise. Fo v2 uses the below functions <code>isGenerator()</code>
and <code>isGeneratorFunction()</code> to determine if the yielded value is a generator
or generator function, respectively.</p>
<p>Co also has similar helper functions, however, co&#39;s checks are more robust.
These functions are meant to be examples, don&#39;t use them in production!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> isGenerator = (v) =&gt; <span class="hljs-keyword">typeof</span> v.next === <span class="hljs-string">'function'</span>;
<span class="hljs-keyword">const</span> isGeneratorFunction =
  (v) =&gt; v.constructor &amp;&amp; v.constructor.name === <span class="hljs-string">'GeneratorFunction'</span>;
</code></pre>
<p>Now that you can check if a value is a generator or a generator function,
the <code>toPromise()</code> function can call <code>fo()</code> recursively to convert the
generator you yielded into a promise.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Convert v to a promise. If invalid, returns a rejected promise</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toPromise</span>(<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">if</span> (isGeneratorFunction(v) || isGenerator(v)) <span class="hljs-keyword">return</span> fo(v);
}
</code></pre>
<p>And now, you can write helper functions that can yield, as long as the helper
function is a generator function too.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> get = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
};
<span class="hljs-comment">// fo v2 in action. Note that you're yielding a generator!</span>
fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Get the HTML for Google's home page</span>
  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">yield</span> get();
}).catch((error) =&gt; done(error));
</code></pre>
<p><br></p>
<p>This new version of fo also enables you to execute requests in parallel.
If you yield an array, fo will execute the array elements in parallel and
return the results as an array. The magic that makes this work is the
<code>toPromise()</code> function&#39;s array handler.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Convert v to a promise. If invalid, returns a rejected promise</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toPromise</span>(<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">if</span> (isGeneratorFunction(v) || isGenerator(v)) <span class="hljs-keyword">return</span> fo(v);
  <span class="hljs-keyword">if</span> (v.then) <span class="hljs-keyword">return</span> v;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> v === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
      v((error, res) =&gt; error ? reject(error) : resolve(res));
    });
  }
  <span class="hljs-comment">// Magic array handler</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(v)) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(v.map(toPromise));
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid yield <span class="hljs-subst">${v}</span>`</span>));
}
</code></pre>
<p>The <code>Promise.all()</code> function is yet another new feature in the ES2015 spec.
The <code>Promise.all()</code> function takes an array of promises and converts them
into a single promise. The <code>Promise.all()</code> promise&#39;s <code>onFulfilled</code> function
gets called when every promise in the array is resolved, and its
<code>onRejected</code> function gets called whenever any of the promises in the array
is rejected.</p>
<p>When your generator function yields an array, the <code>toPromise()</code> function first
uses <code>.map()</code> to convert every element in the array to a promise, and then
passes that array to <code>Promise.all()</code>. This means that the HTTP requests below
execute in parallel.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
fo(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Parallel HTTP requests!</span>
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> [
    superagent.get(<span class="hljs-string">'http://www.google.com'</span>),
    superagent.get(<span class="hljs-string">'http://www.amazon.com'</span>)
  ];
});
</code></pre>
<p>Congratulations, you&#39;ve successfully implemented your own co knockoff!
Co supports all the features of fo, plus a few extra. Go take a look at
the source code for co 4.x on GitHub, it should now look familiar. Don&#39;t
forget the following key points for working with co.</p>
<ul>
<li>Error handling. Make sure to use <code>co().catch()</code>, this will enable you to
catch all errors that occur in your generator function, not just promise
rejections.</li>
<li>Parallelism. Running requests in parallel with co is as simple as yielding
an array. Using parallel requests where possible can give you a big performance
boost.</li>
<li>Internal error handling. If you don&#39;t want an error to stop execution of your
generator function, use try/catch. With co, you can use try/catch to handle
asynchronous errors.</li>
<li>Helper functions. Helper functions can be generator functions as well, just
be sure to use yield.</li>
</ul>
<p><br><br><br></p>
<p>Below is an example of some of the above points in action.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> res;
  <span class="hljs-keyword">try</span> {
    res = <span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    res = getCached();
  }

  <span class="hljs-comment">// Any errors with this get sent to handleError</span>
  <span class="hljs-comment">// The `persistToDb()` function is a generator function.</span>
  <span class="hljs-keyword">yield</span> persistToDb(res.text);
}).catch(handleError);
</code></pre>
<h1 id="chapter-3-koa-and-middleware">Chapter 3: Koa and Middleware</h1>
<p>Co and the notion of asynchronous coroutines enable you to write asynchronous
code with cleaner syntax. However, co is useful for more than just writing
HTTP requests without callbacks. As you saw in the &quot;Real Implementation of Co&quot;
section, co supports generators as an asynchronous primitive. You used this
idea to write helper functions that were also generators. The idea of yielding
generators is useful for composing asynchronous functions, which leads to the
idea of middleware.</p>
<p>The concept of <strong>middleware</strong> in JavaScript is a sequence of functions where
one function is responsible for calling the next function in the sequence.
Conventional ES5-style middleware has the below form.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> middlewareFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>{
  <span class="hljs-comment">// A middleware function takes in the request and response,</span>
  <span class="hljs-comment">// transforms them, and calls `next()` to trigger the next</span>
  <span class="hljs-comment">// function in the middleware chain.</span>
  next();
};
</code></pre>
<p>However, this function composition paradigm has numerous limitations. Once a
middleware function calls <code>next()</code>, it defers control to the next function
in the sequence. There is no way for the next function to return any values
or defer control back to the previous middleware. In other words, what if
you wanted to write a middleware function that reported how long the
rest of the sequence of functions took to complete?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> middlewareFn = (req, res, next) =&gt; {
  <span class="hljs-comment">// next() is async and does not return a promise, nor does it</span>
  <span class="hljs-comment">// take a callback.</span>
  next();
};
</code></pre>
<p>The <code>next()</code> call fires off the next middleware in the chain, but there is no
way for the middleware function above to know when <code>next()</code> is done.
However, suppose your middleware functions were generator functions rather
than regular functions, and suppose <code>next()</code> returned a promise. If you
wrapped the middleware generator functions in a <code>co()</code> call, you would now
have the ability to compose asynchronous coroutines: the first coroutine calls
the second and so on, and then the first coroutine picks up where it left off
after the second is done.</p>
<p><br><br><br><br><br><br><br><br><br></p>
<p>The generator-based function composition library koa-compose does exactly
this. The <code>next</code> parameter is a generator function that triggers the next
generator in the sequence. In the below example, <code>middleware1</code> yields
next to defer control to <code>middleware2</code>, which takes approximately 100ms
to run, and picks up where it left off after <code>middleware2</code> is done.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-compose'</span>);

<span class="hljs-keyword">const</span> middleware1 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">yield</span> next;
  <span class="hljs-comment">// Approximately 100</span>
  <span class="hljs-keyword">const</span> end = <span class="hljs-built_in">Date</span>.now() - start;
};

<span class="hljs-keyword">const</span> middleware2 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// Yield a thunk that gets resolved after 100 ms</span>
  <span class="hljs-keyword">yield</span> callback =&gt; setTimeout(() =&gt; callback(), <span class="hljs-number">100</span>);
  <span class="hljs-keyword">yield</span> next;
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> compose([middleware1, middleware2])();
});
</code></pre>
<h2 id="the-koa-compose-module">The koa-compose Module</h2>
<p>The koa-compose module that you saw in this chapter&#39;s introduction is trivial
to implement. The key idea is that the <code>next</code> generator function that each
middleware gets is a generator which, when completed, means that each
subsequent middleware has completed. In other words, the <code>next</code> parameter
to each generator function needs to be a generator derived from the next
generator function in the sequence as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> compose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">middleware</span>) </span>{
  <span class="hljs-keyword">const</span> noop = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{};
  <span class="hljs-comment">// compose returns a generator</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> i = middleware.length;
    <span class="hljs-keyword">let</span> next = noop;
    <span class="hljs-keyword">while</span> (i--) {
      <span class="hljs-comment">// Loop over generators from last to first. The `next` passed</span>
      <span class="hljs-comment">// to the i-th generator function is the (i+1)-th generator.</span>
      next = middleware[i](next);
    }
    <span class="hljs-keyword">yield</span> next;
  };
};
</code></pre>
<p><br><br></p>
<p>The real implementation of koa-compose is almost identical to the above
implementation, just with better support for the <code>this</code> keyword. The <code>this</code>
keyword will be important in the koa section. But, before you learn about koa,
let&#39;s take a look at how error handling works in koa-compose.</p>
<p>Remember that koa-compose doesn&#39;t add any special error handling on top of
co and generators. If the first middleware in the chain throws an error,
the subsequent middleware functions never execute, and the <code>yield</code> statement
that calls the composed function will throw an error.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-compose'</span>);

<span class="hljs-keyword">const</span> middleware1 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>);
};

<span class="hljs-keyword">const</span> middleware2 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// never get here</span>
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// This will throw an error</span>
  <span class="hljs-keyword">yield</span> compose([middleware1, middleware2])();
}).catch(error =&gt; {
  <span class="hljs-comment">// Error: oops</span>
});
</code></pre>
<p>One neat feature of this middleware paradigm is that you can define error
handling middleware using try/catch. Since the way you defer control to the
next generator function in the sequence is by yielding on a generator,
surrounding the <code>yield next</code> call in a try/catch will catch <strong>any</strong> errors
that the subsequent functions in the sequence throw.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> error;
<span class="hljs-keyword">const</span> middleware1 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// The `middleware2` generator function throws...</span>
    <span class="hljs-keyword">yield</span> next;
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// which triggers this try/catch and records the error</span>
    error = err;
  }
};

<span class="hljs-keyword">const</span> middleware2 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Will get caught'</span>);
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// `res` will be -1 since the final value returned by middleware1</span>
  <span class="hljs-comment">// is -1</span>
  <span class="hljs-keyword">yield</span> compose([middleware1, middleware2])();
  <span class="hljs-comment">// error is now 'Error: Will get caught'</span>
});
</code></pre>
<h2 id="the-koa-web-framework">The Koa Web Framework</h2>
<p>The most important application of koa-compose and generator-based middleware
is a web framework called koa. Koa is a thin layer on top of koa-compose that
makes it easier to write web servers using generator-based middleware. The
below example creates a koa HTTP server that displays &quot;Hello, World!&quot; when
you open <code>http://localhost:3000</code> in a browser.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-comment">// Create a new koa app</span>
<span class="hljs-keyword">const</span> app = koa();
<span class="hljs-comment">// Each app has its own sequence of middleware. The `.use()`</span>
<span class="hljs-comment">// function adds a generator function to the middleware chain.</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// `superagent.get('http://localhost:3000');` will now</span>
  <span class="hljs-comment">// return 'Hello, World!'</span>
  <span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Hello, World!'</span>;
});
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p>The goal of this section is to write your own minimal take on koa. Koa is just
a thin layer on top of koa-compose with some HTTP-specific syntactic sugar.
Recall that koa-compose retains the same <code>this</code> across all middleware functions.
In order to craft a response to an incoming HTTP request, koa requires you to
set properties on <code>this</code>, also known as the koa <strong>context</strong>.</p>
<p>Before you implement your own minimal koa, there&#39;s a couple key concepts you
should be aware of. First, generator functions have a context
(the value of the <code>this</code> keyword) just like
regular JavaScript functions. The easiest way to call a generator with a
pre-defined value of <code>this</code> is the <code>call()</code> function defined on every JavaScript
function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Will print 'Hello, World!'</span>
  <span class="hljs-keyword">yield</span> generatorFunction.call(<span class="hljs-string">'Hello, World!'</span>);
});
</code></pre>
<p>The other key concept is the Node.js HTTP package. The ability to start an
HTTP server is part of core Node.js. Here&#39;s how you would start an HTTP server
on port 3000 that prints out &quot;Hello, World!&quot; as a response to every request.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-comment">// Create a new server with a request handler. `req` represents</span>
<span class="hljs-comment">// the request, and `res` represents the response.</span>
<span class="hljs-keyword">const</span> server = http.createServer((req, res) =&gt; res.end(<span class="hljs-string">'Hello, World!'</span>));
<span class="hljs-comment">// Listen on port 3000</span>
server.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p><br><br></p>
<p>The downside of Node.js&#39; vanilla HTTP package is that it doesn&#39;t provide an
easy way to compose request handlers. You pass <code>createServer()</code> a function
that takes in a request and a response, and you&#39;re responsible for figuring
out what that function should be. Koa enables you to use koa-compose to compose
generator functions into a route handler that&#39;s compatible with Node.js&#39; HTTP
server package. With that in mind, below is a minimal implementation of koa
that is sufficient to run your basic &quot;Hello, World&quot; example.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> co = <span class="hljs-built_in">require</span>(<span class="hljs-string">'co'</span>);
<span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-compose'</span>);

<span class="hljs-comment">// The minimal koa implementation</span>
<span class="hljs-keyword">const</span> koa = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// List of middleware</span>
  <span class="hljs-keyword">let</span> middleware = [];

  <span class="hljs-comment">// The real work is in this function, which creates the</span>
  <span class="hljs-comment">// actual HTTP server</span>
  <span class="hljs-keyword">const</span> listen = (port) =&gt; {
    <span class="hljs-comment">// First, koa-compose all the middleware together</span>
    <span class="hljs-keyword">const</span> composedMiddleware = compose(middleware);
    <span class="hljs-comment">// Create a server with a co-based request handler</span>
    <span class="hljs-keyword">const</span> server = http.createServer((req, res) =&gt; {
      co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">const</span> context = {};
        <span class="hljs-comment">// Execute all the middleware using the empty context object</span>
        <span class="hljs-keyword">yield</span> composedMiddleware.call(context);
        <span class="hljs-comment">// Once the middleware is done, send the request body</span>
        res.end(context.body);
      });
    });
    <span class="hljs-keyword">return</span> server.listen(port);
  };

  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// The `use()` function just adds a new generator function to</span>
    <span class="hljs-comment">// the list of middleware</span>
    use: (middlewareFn) =&gt; middleware.push(middlewareFn),
    listen: listen
  };
};

<span class="hljs-comment">// Create a new koa app</span>
<span class="hljs-keyword">const</span> app = koa();
<span class="hljs-comment">// Each app has its own sequence of middleware. The `.use()`</span>
<span class="hljs-comment">// function adds a generator function to the middleware chain.</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-comment">// `superagent.get('http://localhost:3000');` will now</span>
  <span class="hljs-comment">// return 'Hello, World!'</span>
  <span class="hljs-keyword">this</span>.body = <span class="hljs-string">'Hello, World!'</span>;
});
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<p><br><br></p>
<p>The real implementation of koa includes many more features, but the fundamental
idea is similar to the previous implementation. In particular, the request
handler koa 1.x passes to the Node.js <code>http.createServer()</code> function is just
the result of running koa-compose on the app&#39;s middleware plus
post-processing to translate the <code>context</code> object into an HTTP response.</p>
<p>For instance, the real implementation of koa exposes the request and response
objects on the request context. In the minimal koa implementation, your
middleware doesn&#39;t know anything about incoming requests, which makes it
impossible to craft a real response. Supporting
this feature would look like what you see below.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// Create a server with a co-based request handler</span>
<span class="hljs-keyword">const</span> server = http.createServer((req, res) =&gt; {
  co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Expose req and res by default</span>
    <span class="hljs-keyword">const</span> context = { req: req, res: res };
    <span class="hljs-comment">// Execute all the middleware using the empty context object</span>
    <span class="hljs-keyword">yield</span> composedMiddleware.call(context);
    <span class="hljs-comment">// Once the middleware is done, send the request body</span>
    res.end(context.body);
  });
});
</code></pre>
<p>Koa&#39;s middleware approach has some neat features. For instance, it is difficult
to define a catch-all error handler in web frameworks like Express. However, in
koa, defining an error handler is a trivial application of try/catch.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'superagent'</span>);
<span class="hljs-keyword">const</span> app = koa();

<span class="hljs-comment">// The first middleware is an error handler: if any subsequent</span>
<span class="hljs-comment">// middleware throws an error, this try/catch will handle it.</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> next;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">this</span>.body = error.toString();
    <span class="hljs-keyword">this</span>.status = <span class="hljs-number">500</span>;
  }
});

<span class="hljs-comment">// So if google.com is down, this middleware will throw an error,</span>
<span class="hljs-comment">// and the above middleware will report it as an HTTP 500.</span>
app.use(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">this</span>.body = (<span class="hljs-keyword">yield</span> superagent.get(<span class="hljs-string">'http://www.google.com'</span>)).text;
  <span class="hljs-keyword">yield</span> next;
});

app.listen(<span class="hljs-number">3000</span>);
</code></pre>
<h2 id="limitations-of-koa-compose">Limitations of koa-compose</h2>
<p>Koa and koa-compose are powerful tools, but they are far from perfect. At the
time of this writing, koa 2 is in alpha release and completely breaks the
koa 1 API that you learned about in the koa section. Koa 1 also supports
the composition module as a replacement for koa-compose. What&#39;s the issue
with koa-compose? The first issue is koa-compose doesn&#39;t properly support
returning values from middleware.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> compose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa-compose'</span>);

<span class="hljs-keyword">const</span> middleware1 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> next;
  <span class="hljs-keyword">return</span> res + <span class="hljs-string">'World!'</span>;
};

<span class="hljs-keyword">const</span> middleware2 = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, '</span>;
};

co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> compose([middleware1, middleware2])();
  <span class="hljs-comment">// res is undefined!</span>
});
</code></pre>

    </div>
    <script type="text/javascript">
      var start = 3410;
      var delta = 1680;
      for (var i = 2; i < 34; ++i) {
        var height = start + (i - 2) * delta;
        document.write('<div class="page-num" style="top:' + height + 'px;">' + (i - 1) + '</div>');
      }
    </script>
  