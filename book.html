
    <link href='http://fonts.googleapis.com/css?family=Titillium+Web' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
    <style>
      html {
  font-family: 'Roboto';
  font-size: 24px;
}

h1 {
  padding-top: 100px;
  page-break-before: always;
}

h2 {
  padding-top: 75px;
}

.page-break {
  page-break-before: always;
}

h1,h2,h3,h4,p,ul,ol,pre {
  margin-left: 50px;
  margin-right: 50px;
}

pre {
  border: 1px solid #dfdfdf;
  padding: 15px;
}

code {
  font-family: 'Droid Sans Mono';
}

p {
  line-height: 1.5em;
}

p code {
  color: #232323;
}

li {
  margin-left: 50px;
}

a {
  color: black;
  float: right;
  text-decoration: none;
  font-weight: bold;
}

.page-num {
  position: absolute;
  right: 50px;
  font-size: 0.75em;
  font-color: #333333;
}

.cover img {
  position: relative;
  left: -250px;
  top: -8px;
  height: 1300px;
  margin: 0px;
  padding: 0px;
}

.cover .info {
  position: absolute;
  top: 1240px;
  left: -8px;
  background-color: black;
  color: white;
  height: 441px;
  width: 1500px;
}

.title {
  padding-left: 50px;
  font-family: 'Titillium Web';
  font-size: 48pt;
  font-weight: bold;
}

.author {
  padding-left: 50px;
  font-family: 'Titillium Web';
  font-size: 36pt;
  margin-top: 15px;
}

.top-triangle {
  position: absolute;
  top: 1100px;
  left: 0px;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 200px 0 0 2000px;
  border-color: transparent transparent transparent black;
}

/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-javadoc {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.css .rule .hljs-keyword,
.hljs-winutils,
.nginx .hljs-title,
.hljs-subst,
.hljs-request,
.hljs-status {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-hexcolor,
.ruby .hljs-constant {
  color: #008080;
}

.hljs-string,
.hljs-tag .hljs-value,
.hljs-phpdoc,
.hljs-dartdoc,
.tex .hljs-formula {
  color: #d14;
}

.hljs-title,
.hljs-id,
.scss .hljs-preprocessor {
  color: #900;
  font-weight: bold;
}

.hljs-list .hljs-keyword,
.hljs-subst {
  font-weight: normal;
}

.hljs-class .hljs-title,
.hljs-type,
.vhdl .hljs-literal,
.tex .hljs-command {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-tag .hljs-title,
.hljs-rules .hljs-property,
.django .hljs-tag .hljs-keyword {
  color: #000080;
  font-weight: normal;
}

.hljs-attribute,
.hljs-variable,
.lisp .hljs-body {
  color: #008080;
}

.hljs-regexp {
  color: #009926;
}

.hljs-symbol,
.ruby .hljs-symbol .hljs-string,
.lisp .hljs-keyword,
.clojure .hljs-keyword,
.scheme .hljs-keyword,
.tex .hljs-special,
.hljs-prompt {
  color: #990073;
}

.hljs-built_in {
  color: #0086b3;
}

.hljs-preprocessor,
.hljs-pragma,
.hljs-pi,
.hljs-doctype,
.hljs-shebang,
.hljs-cdata {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.diff .hljs-change {
  background: #0086b3;
}

.hljs-chunk {
  color: #aaa;
}

    </style>
    <div id="content">
      <div class="cover">
  <img src="http://i.imgur.com/nG4gisP.jpg" />
  <div class="top-triangle"></div>
  <div class="info">
    <div class="title">
      The 80/20 Guide to ES2015 Generators
    </div>
    <div class="author">
      Valeri Karpov
    </div>
  </div>
</div>

      <h1 id="table-of-contents">Table of Contents</h1>
<h3 id="1-getting-started-with-generators-1-2-">1. Getting Started With Generators <a href="#2">1</a></h3>
<ol>
<li>What is a Generator? <a href="#2">1</a></li>
<li>Case Study: Async Fibonacci <a href="#3">3</a></li>
<li>For/Of Loops <a href="#5">5</a></li>
<li>Exceptions</li>
<li>Case Study: Handling Async Errors</li>
</ol>
<h3 id="2-coroutines">2. Coroutines</h3>
<ol>
<li>How Does Co Work?</li>
<li>Using Thunks</li>
<li>Limitations</li>
<li>The Real Implementation of Co</li>
<li>Case Study: HTTP Requests with Co</li>
</ol>
<h3 id="3-koa-and-middleware">3. Koa and Middleware</h3>
<ol>
<li>The Composition Module</li>
<li>Writing Your Own Generator-Based Middleware</li>
<li>Introducing Koa</li>
<li>Case Study: Koa Error Handling Middleware</li>
</ol>
<h3 id="4-transpiling">4. Transpiling</h3>
<ol>
<li>Introducing <code>regenerator</code></li>
<li>Parsing Generators With Esprima</li>
<li>Write Your Own Transpiler</li>
</ol>
<h3 id="5-moving-on">5. Moving On</h3>

      <h1 id="chapter-1-getting-started">Chapter 1: Getting Started</h1>
<p>Generators are a powerful new feature in ES2015. Generators are far from a
new programming construct - they first appeared in 1975 and Python has had
them since Python 2.2 in 2001. However, as you&#39;ll see, generators are
even more powerful in an event-driven language like JavaScript. In JavaScript
(assuming Node.js &gt;= 4.0.0), a <strong>generator function</strong> is defined as shown below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);
};
</code></pre>
<p>However, if you run <code>generatorFunction</code>, you&#39;ll notice that the return value
is an object.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>); };
<span class="hljs-literal">undefined</span>
&gt; generatorFunction()
{}
</code></pre><p>That&#39;s because a generator function creates and returns a <strong>generator object</strong>.
Typically, the term <strong>generator</strong> refers to a generator object rather than
a generator function. A generator object has a single function, <code>next()</code>.
If you execute the generator object&#39;s <code>next()</code> function, you&#39;ll notice
that Node.js printed &#39;Hello, World!&#39; to the screen.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>); };
<span class="hljs-literal">undefined</span>
&gt; generatorFunction()
{}
&gt; generatorFunction().next()
Hello, World!
{ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> }
&gt;
</code></pre><p>Notice that <code>next()</code> returned an object, <code>{ value: undefined, done: true }</code>.
The meaning of this object is tied to the <code>yield</code> keyword. To introduce you
to the <code>yield</code> keyword, consider the following generator function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>;
};
</code></pre>
<p><br><br><br><br><br>
<br></p>
<p>Let&#39;s see what happens when you call <code>next()</code> on the resulting generator.</p>
<pre><code>$ node
&gt; <span class="hljs-keyword">var</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">yield</span> <span class="hljs-string">'Hello, World!'</span>; };
<span class="hljs-literal">undefined</span>
&gt; <span class="hljs-keyword">var</span> generator = generatorFunction();
<span class="hljs-literal">undefined</span>
&gt; generator.next();
{ value: <span class="hljs-string">'Hello, World!'</span>, done: <span class="hljs-literal">false</span> }
&gt; generator.next();
{ value: <span class="hljs-literal">undefined</span>, done: <span class="hljs-literal">true</span> }
&gt;
</code></pre><p>Notice that, the first time you call <code>generator.next()</code>, the <code>value</code> property
is equal to the string your generator function yielded. You can think of
<code>yield</code> as the generator-specific equivalent of the <code>return</code> statement.</p>
<p>You might be wondering why the return value of <code>generator.next()</code> has a <code>done</code>
property. The reason is tied to why <code>yield</code> is different from <code>return</code>.</p>
<h3 id="-yield-vs-return-"><code>yield</code> vs <code>return</code></h3>
<p>The <code>yield</code> keyword can be thought of as a <code>return</code> that allows <strong>re-entry</strong>.
In other words, once <code>return</code> executes, the currently executing function is
done forever. However, when you call <code>generator.next()</code>, the JavaScript
interpreter executes the generator function until the first <code>yield</code> statement.
When you call <code>generator.next()</code> again, the generator function picks up where
it left off. You can think of a generator as a function that can &quot;return&quot;
multiple values.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">'Hello'</span>;
  <span class="hljs-keyword">yield</span> message;
  message += <span class="hljs-string">', World!'</span>;
  <span class="hljs-keyword">yield</span> message;
};

<span class="hljs-keyword">const</span> generator = generatorFunction();
<span class="hljs-comment">// { value: 'Hello', done: false };</span>
<span class="hljs-keyword">const</span> v1 = generator.next();
<span class="hljs-comment">// { value: 'Hello, World!', done: false }</span>
<span class="hljs-keyword">const</span> v2 = generator.next();
<span class="hljs-comment">// { value: undefined, done: true }</span>
<span class="hljs-keyword">const</span> v3 = generator.next();
</code></pre>
<h3 id="re-entry">Re-entry</h3>
<p>The most important detail from the above example is that, when <code>yield</code>
executes, the generator function stops executing until the next time you call
<code>generator.next()</code>. You can call <code>generator.next()</code> whenever you want, even in
a <code>setTimeout()</code>. The JavaScript interpreter will re-enter the generator
function with the same state that it left off with.</p>
<p><br>
<br></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>) {
    <span class="hljs-keyword">yield</span> i;
    ++i;
  }
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-keyword">let</span> x = generator.next(); <span class="hljs-comment">// { value: 0, done: false }</span>
setTimeout(() =&gt; {
  x = generator.next(); <span class="hljs-comment">// { value: 1, done: false }</span>
  x = generator.next(); <span class="hljs-comment">// { value: 2, done: false }</span>
  x = generator.next(); <span class="hljs-comment">// { value: undefined, done: true }</span>
}, <span class="hljs-number">50</span>);
</code></pre>
<h3 id="-yield-vs-return-revisited"><code>yield</code> vs <code>return</code> revisited</h3>
<p>You may be wondering what happens when you use <code>return</code>
instead of <code>yield</code> in a generator. As you might expect,
<code>return</code> behaves similarly to <code>yield</code>, except for
<code>done</code> is set to true.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> generatorFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, World!'</span>;
};

<span class="hljs-keyword">const</span> generator = generatorFunction();

<span class="hljs-comment">// { value: 'Hello, World!', done: true }</span>
<span class="hljs-keyword">const</span> v = generator.next();
</code></pre>
<h2 id="case-study-async-fibonacci">Case Study: Async Fibonacci</h2>
<p>The fact that you can execute <code>generator.next()</code> asynchronously hints at
why generators are so useful. You can execute <code>generator.next()</code> synchronously
or asynchronously without changing the implementation of the generator
function.</p>
<p><div class="page-break"></div>
<br><br></p>
<p>For instance, lets say you wrote a generator
function that computes the Fibonacci Sequence. Note that generator functions
can take parameters like any function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacciGenerator = <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">let</span> back2 = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> back1 = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) {
    cur = back2 + back1;
    back2 = back1;
    back1 = cur;
    <span class="hljs-keyword">yield</span> cur;
  }

  <span class="hljs-keyword">return</span> cur;
};
</code></pre>
<p>You could compute the n-th Fibonacci number synchronously using the code
below.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-keyword">let</span> it;
<span class="hljs-keyword">for</span> (it = fibonacci.next(); !it.done; it = fibonacci.next()) {}
it.value; <span class="hljs-comment">// 55, the 10th fibonacci number</span>
</code></pre>
<p>However, computing the n-th Fibonacci number synchronously is not a hard
problem without generators. To make things interesting, let&#39;s say you wanted
to compute a very large Fibonacci number <strong>without blocking the event loop</strong>.
Normally, a JavaScript for loop would block the event loop. In other words,
no other JavaScript code can execute until the for loop in the previous
example is done. This can get problematic if you want to compute the 100
millionth Fibonacci number in an Express route handler. Without generators,
breaking up a long-running calculation can be cumbersome.</p>
<p>However, since you have a generator function that yields after each iteration
of the for loop, you can call <code>generator.next()</code> in a <code>setInterval()</code>
function. This will compute the next Fibonacci number with each iteration of
the event loop, and so won&#39;t prevent Node.js from responding from incoming
requests. You can make your Fibonacci calculation asynchronous without
changing the generator function!</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-comment">// And compute one new Fibonacci number with each iteration</span>
<span class="hljs-comment">// through the event loop.</span>
<span class="hljs-keyword">const</span> interval = setInterval(() =&gt; {
  <span class="hljs-keyword">const</span> res = fibonacci.next();
  <span class="hljs-keyword">if</span> (res.done) {
    clearInterval(interval);
    res.value; <span class="hljs-comment">// 55, the 10th fibonacci number</span>
  }
}, <span class="hljs-number">0</span>);
</code></pre>
<h2 id="for-of-loops">For/Of Loops</h2>
<p>Remember the for loop you saw for exhausting the Fibonacci generator?</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (it = fibonacci.next(); !it.done; it = fibonacci.next()) {}
</code></pre>
<p>This for loop is a perfectly reasonable way of going through every value of
the generator. However, ES2015 introduces a much cleaner mechanism for
looping through generators: the <code>for-of</code> loop.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  x; <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
</code></pre>
<h3 id="iterators-and-iterables">Iterators and Iterables</h3>
<p>For/Of loops aren&#39;t just for generators. A generator is actually an instance
of a more general ES2015 concept called an iterator. An <strong>iterator</strong> is
any JavaScript object that has a <code>next()</code> function that returns
<code>{ value: Any, done: Boolean }</code>. A generator is one example of an iterator.
You can also iterate over arrays:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) {
  x; <span class="hljs-comment">// 1, 2, 3</span>
}
</code></pre>
<p>However, For/Of loops don&#39;t operate on iterators, they operate on iterables.
An <strong>iterable</strong> is an object that has a <code>Symbol.iterator</code> property which is
a function that returns an iterator. In other words, when you execute a
For/Of loop, the JavaScript interpreter looks for a <code>Symbol.iterator</code> property
on the object you&#39;re looping <code>of</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> iterable = {};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {} <span class="hljs-comment">// Throws an error</span>

<span class="hljs-comment">// But once you add a Symbol.iterator property, everything works!</span>
iterable[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fibonacciGenerator(<span class="hljs-number">10</span>);
};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> iterable) {
  x; <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
</code></pre>
<h3 id="a-brief-overview-of-symbols">A Brief Overview of Symbols</h3>
<p><strong>Symbols</strong> are another new feature in ES2015. Since this book is about
generators, we won&#39;t explore symbols in depth, just enough to understand
what the mysterious <code>iterable[Symbol.iterator]</code> code in the previous example
is about.</p>
<p><br><br><br></p>
<p>You can think of a symbol as a unique identifier for a key on an object.
For instance, suppose you wrote your own programming language and defined
an iterable as an object that had a property named <code>iterator</code>. Now, every
object that has a property named <code>iterator</code> would be an iterable, which
could lead to some unpredictable behavior. For instance, suppose you added
a property named <code>iterator</code> to an array - now you&#39;ve accidentally broken
for/of loops for that array!</p>
<p>Symbols protect you from the issue of accidental string collision. No string
key is equal to <code>Symbol.iterator</code>, so you don&#39;t have to worry about
accidentally breaking an iterable. Furthermore, symbols don&#39;t appear in
the output of <code>Object.keys()</code>.</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">Symbol</span>.iterator; <span class="hljs-comment">// Symbol(Symbol.iterator)</span>

<span class="hljs-keyword">let</span> iterable = {};
iterable[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fibonacciGenerator(<span class="hljs-number">10</span>);
};

iterable.iterator; <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Object</span>.keys(iterable); <span class="hljs-comment">// Empty array!</span>
</code></pre>
<h3 id="iterables-and-generators">Iterables and Generators</h3>
<p>The most important detail to note about generators and iterables is that
<em>generator objects</em> are iterables, not <em>generator functions</em>. In order words,
you can&#39;t run a for/of loop on a generator function.</p>
<pre><code class="lang-javascript">fibonacciGenerator[<span class="hljs-built_in">Symbol</span>.iterable]; <span class="hljs-comment">// Undefined</span>
fibonacciGenerator(<span class="hljs-number">10</span>)[<span class="hljs-built_in">Symbol</span>.iterable]; <span class="hljs-comment">// Function</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacciGenerator) {} <span class="hljs-comment">// Error!</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacciGenerator(<span class="hljs-number">10</span>)) {} <span class="hljs-comment">// Ok</span>
</code></pre>
<p>You may find it strange that the generator&#39;s
<code>Symbol.iterator</code> function returns itself given that generator functions are
not iterable. One reason for this decision is that a generator function can
take parameters. For instance, looping over <code>fibonacciGenerator(10)</code> would not
give the same results as looping over <code>fibonacciGenerator(11)</code>.</p>
<p>The second most important detail to note about generators and iterables
is that <code>generator[Symbol.iterator]</code> is a function that returns the
generator itself. This means that you can&#39;t loop over the same generator
twice. Once a generator is done, subsequent for/of loops will exit immediately.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fibonacci = fibonacciGenerator(<span class="hljs-number">10</span>);
fibonacci[<span class="hljs-built_in">Symbol</span>.iterator]() === fibonacci; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  <span class="hljs-comment">// 1, 1, 2, 3, 5, ..., 55</span>
}
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> fibonacci) {
  <span class="hljs-comment">// Doesn't run!</span>
}
</code></pre>

    </div>
    <script type="text/javascript">
      var start = 3400;
      var delta = 1680;
      var pageHeights = [3400, 5080, 6760, 8440, 10120];
      for (var i = 2; i < 8; ++i) {
        var height = start + (i - 2) * delta;
        document.write('<div class="page-num" style="top:' + height + 'px;">' + (i - 1) + '</div>');
      }
    </script>
  